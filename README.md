# 기능 구현 목록

## problem 1

- 페이지가 유효한지 검사
  - 왼쪽 페이지가 홀수
  - 오른쪽 페이지가 왼쪽 페이지가 이어지는지 (오른쪽 페이지 === 왼쪽 페이지 + 1)
- 왼쪽, 오른쪽 페이지의 각 자리 수를 더하거나 곱했을 때 가장 큰 수 구하기
- 비교하여 결과 도출

## problem 2

1. 문자열을 배열로 변경
2. 인덱스를 상승시키면서 전 인덱스의 문자와 같은지 체크
3. 만약 같다면 그 후의 연속되는 몇 개의 인덱스의 문자가 동일한지 체크
4. 같은 문자가 연속되는 문자열을 잘라내기
5. 인덱스 조정
6. 2-5단계를 반복
7. 연속 중복되는 문자를 제거한 문자열 반환

## problem 3

- 1에서 number까지 1씩 상승시킴
- 숫자를 문자열로 변경후 3,6,9의 갯수 체크
- 총 갯수 반환

## problem 4

- 아스키코드를 사용
- 대문자, 소문자, 스페이스 아스키코드 구별
- 변환할때 정반대의 위치로 이동하므로 변환할 문자가 몇 번째 순서인지 파악하고 뒤에서부터 그 순서의 알파벳을 찾는다.
  - ex) B는 1번째 알파벳이다.(0부터 시작) Y는 뒤에서 두번째 알파벳이다. B->Y
  - ex) B는 1번째 알파벳이다.(0부터 시작) -> B의 아스키코드 - A의 아스키코드 -> 66 - 65 -> 1
  - ex) 뒤에서부터 1번째 알파벳은? -> Z의 아스키코드 - 1 -> 90 - 1 -> 89 -> Y

## problem 5

- 화폐 단위 배열 생성
- 돈을 화폐 단위마다 사용할 수 있는 갯수를 계산하고 화폐를 사용한 후 나머지 돈을 구함
  
## problem 6

- '같은 글자가 연속적으로 포함'은 두 글자만 연속되어도 중복된다는 것을 뜻함
- 닉네임을 두글자씩 잘라서 Map에 삽입 ex) key:두글자 닉네임, value:[...이메일]
- Map을 순회하면서 이메일 배열의 길이가 2개 이상일 경우 중복되는 것이므로 set에 이메일들 삽입
- set을 배열로 변환, 정렬 후 반환

## problem 7

- 객체를 이용하여 사람마다 친구 목록을 생성한다.
- 자신의 친구와 자신을 다른 사람들의 친구 목록에서 제거한다.
- 점수 객체를 생성한다. (property:사용자, value:점수)
- 자신을 제외한 사용자의 친구 목록에 존재하는 사람들을 체크하여 10점씩 부여한다. (남은 사람들은 친구의 친구임)
- 방문자 목록을 순회하여 1점씩 부여한다.
- 점수 객체를 배열로 변환한후 이름 순으로 정렬 후 점수 순으로 정렬한다.