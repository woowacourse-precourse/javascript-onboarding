# 온보딩 소감문

## 문제1. 페이지 번호 게임

### 분석: 연산자와 형변환, 조건문 및 반복문을 활용할 수 있는지 알아보는 문제

- 기본적인 문법만 사용하면 풀 수 있는 간단한 문제였다.
- 다만, 비교해야하는 횟수가 기본적으로 (1)덧셈과 곱셈 비교 (2)홀짝 페이지 비교 (3)게임 참가자끼리 비교. 이렇게 세번 반복되므로 자칫하면 코드가 지저분해질 수도 있었다.
- 코드를 최대한 깔끔하게 작성하기 위해 각 비교마다 조건문을 함수로 작성하여 비교했다. 
- 간단한 조건문 작성에서는 삼항연산자를 사용했다. Javascript는 다른 언어와 달리 삼항연산자라는 fancy한 기능을 지원한다. 
- 중첩 if문을 사용할 경우에는 삼항연산자보다는 그냥 else if를 사용하는 것이 훨씬 보기 좋은 것 같다.

## 문제2. 암호 해독

### 분석: 반복문 혹은 stack을 사용해야하는 문제

- 반복문을 사용하여 앞글자부터 brute force를 사용하면 풀 수 있는 문제였다.
- 하지만 일일이 한 글자씩 비교하다보면 시간이 너무 오래 걸리는 흠이 있었다.
- 시간을 단축하기 위해 stack을 사용하기로 한다. Javascript에서는 push와 pop으로 배열을 stack처럼 사용할 수 있었다. 
- stack을 사용하여 비교하는 문자가 이미 stack에 존재하면 pop하는 방식으로 제거하면 시간을 단축시킬수 있다.

## 문제3. 369게임

### 분석: % 연산자 / 연산자를 조합하여 사용하는 문제

- 처음에는 그냥 단순한 반복문 문제인 줄 알고 Brute force로 풀려고 했었다. 
- Brute force로 문제를 풀려고 할 경우, 입력 숫자가 크면 너무 많은 경우의 수를 검사해야하므로 다른 방법을 모색했다.
- % 연산자를 사용한 후, / 연산자를 사용하면 각 자릿수의 숫자가 무엇인지 검사할 수 있다.
- 각 자릿수를 검사하여 count를 올려주는 방식으로 풀면 시간을 단축시킬 수 있었다. 

## 문제4. 청개구리 사전

### 분석: 유니코드 활용하는 문제

- 처음에는 객체를 사용하여 각 알파벳에 대응하는 알파벳을 적는 방식으로 저장한 다음 객체의 key 값을 이용하여 value를 찾는 방식을 사용하려고 했었다.
- 다시 살펴보니 청개구리 사전에는 일련의 규칙이 있었다. 청개구리는 알파벳의 역순으로 말한다는 점이었다.  
- 다른 언어와 마찬가지로 Javascript에서도 유니코드 변환을 지원했었다. 그러므로 메모리 공간도 절약할 겸, 굳이 객체를 사용할 이유는 없었다.
- str.CharCodeAt(index)를 사용하면 decimal number가 나오는데, 처음에는 hexadecimal인 줄 알고 테스트 하다가 원하는 대로 변환이 되지 않아, 혼돈이 왔었다.
- 곧이어 구글에 유니코드 변환표를 찾아보고서, 동일한 char에 대해 dec와 hex 변환값을 비교해보고, CharCodeAt의 return값이 decimal인 점을 확인하였다.
- 이를 이용하여 대문자와 소문자인 경우를 나누고, A(a)의 decimal number와 Z(z)의 decimal number를 각각 합한 값에서 CharCodeAt한 값을 빼면 청개구리 사전 출력이 완성되었다. 
- 문자가 공백인 경우에는 그냥 continue를 추가하여 판별에 소요되는 시간을 절약했다.

## 문제5. 돈 인출

### 분석: 그리디 알고리즘을 활용하는 문제

- 동전 단위가 나열되어있고 인출해야한다는 문제를 보고 바로 감이 왔다. 이것은 그리디 알고리즘을 사용해야하는 문제라는 걸.
- 그리디 알고리즘은 부분의 최적이 전체의 최적이 될 때 사용할 수 있는 알고리즘인데, 단위가 정해져있고, 작은 단위로 큰 단위를 온전하게 대체할 수 있는 화폐의 특성상 그리디알고리즘은 문제없이 적용할 수 있었다.
- 각 화폐 단위의 개수를 세도록 배열로 저장 공간을 만들고, 화폐 단위로 주어진 입력값을 계속 나누면서 각 화폐단위의 count를 올리면 간단하게 해결되는 문제.
- 다만 나눗셈을 하고 나서 소수점도 관리해줘야했다. 처음에는 나누기 결과를 Int로 형변환해주지 않아서 count가 잘못들어가는 실수를 범했었다. 
- parseInt를 하면 묻지도 따지지도 않고 숫자를 바로 정수형으로 바꿔주니 간편하게 해결되었다.

## 문제6. 닉네임 중복 잡기

### 분석: 반복문과 include 메소드를 활용하는 문제

- 이 문제의 경우 어떻게든 Brute force 방법으로 푸는 것은 피하고 싶었다. 
- - Brute Force로 문제를 풀 경우 배열 속의 배열에서 문자열의 문자를 하나씩 비교해야하니 반복문 3개가 중첩이 되는 것이고 다른 사용자의 닉네임도 반복문을 사용하여 검사해야하므로 시간복잡도는 급격하게 올라간다.
- 하지만 엄연히 문자 하나하나씩 비교해야하니 Brute force 말고 다른 방법이 딱히 떠오르지가 않았다.
- 그래도 다행인 것은 Javascript에서는 문자열이 특정 문자열을 포함하고 있는지 검사해주는 메소드인 include()가 존재했었다. 이것으로 코드의 상당부분을 단순화시킬 수 있었다.
- 그나마 시간을 단축시키기 위해 비교가 완료되어 중복인 문자로 판별될 경우 배열에서 삭제하는 delete 메소드를 사용했다. 
- delete 메소드를 사용하니 에러가 났다. 루프를 돌다가 존재하지 않는 값을 참조하니 에러가 났었다. 
- delete 메소드를 사용하면 해당 원소는 undefined 상태가 된다. 그러므로 반복문 내에서 원소의 값이 존재하는지 검사하는 조건문만 추가해주면 되었다.

## 문제7. SNS 친구 추천 알고리즘

### 분석: 객체 또는 Hashmap을 사용하고 정렬하는 문제

- 객체를 쓸까 고민하다가, ES6에 새롭게 추가된 map이라는 기능을 사용해보기로 하였다.
- map은 다른 언어에 있는 Hashmap과 크게 다르지 않았다. set으로 값을 넣고, get으로 값을 알아내고, has로 키가 존재하는지 판별한다.
- user의 친구가 누구인지(루프1), 그 친구의 친구가 누가 있는지(루프2), 방문자 점수(루프3)를 알아내기 위해 반복문을 여럿 사용했지만, 중첩되지 않았기 때문에 시간이 크게 늘지는 않을 것으로 생각했다. 
- map에는 entires()라는 메소드가 있는데, 키-값 쌍을 이차원 배열로 돌려주는 것이다. 이것을 "..."으로 분해하는 것과 함께 사용한다면, sort를 적용할 수 있었다.  
- 새롭게 알게된 사실은 Javascript의 sort()가 문자 정렬이라는 것이다. 숫자를 정렬할 때에는 parameter에 (a, b) => (a - b)와 같은 형식을 입력해줘야 올바른 결과를 얻지만, 문자를 정렬할 때는 그냥 sort()만 사용해도 알파벳 순으로 정렬해준다는 것이다.
-  점수가 같을 경우에는 별도의 배열을 만들어서 점수가 같은 경우의 키를 모두 넣으려고 했으나, 중복해서 넣는 것이 문제였다. 조건문을 사용할 수도 있었지만, 그냥 중복을 허용하지 않는 set 구조를 활용했다. 
-  set은 원소를 추가할 때 push()가 아닌 add()를 사용해야했다.
-  Array.from()을 사용하면 set을 배열로 형변환 할 수 있었다. 그대로 sort()까지 사용하면 알파벳 순으로 정렬까지 완료.
-  정렬이 완료된 배열들의 닉네임 값들만 모아서 result에 끼워넣어서 리턴하면 완료.

## git

- github의 push 기능은 이미 자주 사용해왔던 터라 어렵지 않게 활용하였다.
- 다만 다른 사람과 협력할 때, 저장소를 fork하여 branch를 생성은 처음으로 실행해보았다.
- branch 존재 이유가 뭔지 몰랐었는데, 협업에 꼭 필요한 기능임을 알게되었다. 
- 마찬가지로 코드리뷰를 위한 pull request 기능도 처음 활용해보는데, 현업에서는 자주 사용될 것이라 여겨졌다. 

## VSCODE

- IDE와 다르게 VSCODE의 디버깅은 설정부터 불편했었다. 그래서 구글의 console로 코드를 하나하나씩 검증하다가 안되겠다 싶어서 slack를 통하여 Javascript 디버깅 어떻게 하는지 사람들에게 물어봤다.
- VSCODE의 Code Runner extension이 좋다는 조언을 받고 바로 설치했다. 디버깅을 한결 수월하게 할 수 있었다. slack의 존재에 처음으로 고마움을 느꼈다. 
