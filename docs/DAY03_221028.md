# 학습 체크리스트

- [x] git commit message 되돌리는 법
- [ ] 구현 내용 스스로 점검하기

# 학습 내용

## 1️⃣ git commit message 되돌리기

### 문제 발생

오늘 아침에 커밋 로그를 보고 식은땀을 흘렸습니다. 커밋 메세지가 단단히 잘못되었으니까요. 그것도 한둘이 아니라 여러가지였습니다. 문제 2의 기능 추가인데 문제 1이라고 적은 것도 있었고, 문제를 명시하지 않고 커밋한 메세지도 있었습니다.

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/94ec2c92-a524-4b78-8ee9-eecccaa1f613/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221028%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221028T014717Z&X-Amz-Expires=86400&X-Amz-Signature=46bfb6cc1408de0fb6904f6097e543eba649a0b60cd2f8e7261590ad5be5eeb6&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22Untitled.png%22&x-id=GetObject)

### 문제 해결

1. 우선 현재 진행중인 변경사항이 있을 경우 stash를 통해 임시저장해둡니다.

   ```
   git stash save
   ```

1. rebase 명령어를 통해 이전 커밋 메세지를 불러 올 수 있습니다.

   ```
   git rebase -i HEAD~15
   ```

   HEAD~(숫자) : 이 숫자부분은 HEAD로부터 몇 번째 전 로그까지 history가 보여질 것인지 정하는 부분입니다.

1. vi 편집을 통해 변경할 커밋 메세지를 pick에서 reword로 변경후 저장합니다. 여러 개를 선택해도 무방합니다.

   1. `i` : insert
   2. `:wq` : 저장하고 종료

   ![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/66a51d56-daa0-44cb-b1c4-eb535aa87350/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221028%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221028T014805Z&X-Amz-Expires=86400&X-Amz-Signature=1cf7edadb83c269cac84d0f6a999684296d0ac9575d56db803a892e07abc0e80&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22Untitled.png%22&x-id=GetObject)

1. 제 실수겠지만 간혹 편집기에서 나가질 때가 있는데 `git rebase —continue` 명령을 작성하면 나머지 선택된 커밋 메세지를 변경할 수 있습니다.

### 결과

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2ee5d028-fa1b-40fb-8365-e6968d7ab7b0/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20221028%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20221028T014834Z&X-Amz-Expires=86400&X-Amz-Signature=7900ba6cb477ddd5563225c151f7f44d2ea284adedb234e4dab39a56617bc0a9&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22Untitled.png%22&x-id=GetObject)

잘못된 git message를 수정하고 난 제 깃 로그입니다. 앞서 체크한 부분 이외에도 고칠 부분이 많아서 여러번 진행했습니다. 덕분에 실습 많이해서 손에 익어서 좋네요.

🔗 참고자료

| 제목                          | 링크                                                                                               |
| ----------------------------- | -------------------------------------------------------------------------------------------------- |
| stash                         | https://backlog.com/git-tutorial/kr/reference/stash.html                                           |
| rebase                        | https://backlog.com/git-tutorial/kr/stepup/stepup7_6.html                                          |
| 이미 commit한 메세지 수정하기 | https://xtring-dev.tistory.com/entry/Git-이미-commit한-메세지-수정하기-바로-이전그-전리모트-commit |

## 2️⃣ Sort

```jsx
const stringArray = ['Blue', 'Humpback', 'Beluga'];
const numberArray = [40, 1, 5, 200];
const numericStringArray = ['80', '9', '700'];
const mixedNumericArray = ['80', '9', '700', 40, 1, 5, 200];

function compareNumbers(a, b) {
  return a - b;
}

stringArray.join(); // 'Blue,Humpback,Beluga'
stringArray.sort(); // ['Beluga', 'Blue', 'Humpback']

numberArray.join(); // '40,1,5,200'
numberArray.sort(); // [1, 200, 40, 5]
numberArray.sort(compareNumbers); // [1, 5, 40, 200]

numericStringArray.join(); // '80,9,700'
numericStringArray.sort(); // ['700', '80', '9']
numericStringArray.sort(compareNumbers); // ['9', '80', '700']

mixedNumericArray.join(); // '80,9,700,40,1,5,200'
mixedNumericArray.sort(); // [1, 200, 40, 5, '700', '80', '9']
mixedNumericArray.sort(compareNumbers); // [1, 5, '9', 40, '80', 200, '700']
```

MDN에 나와있는 sort 코드의 예시입니다. 보시는 거와 같이 문자열(string)의 경우 sort 메소드의 인자로 callback함수를 넣지 않아도 오름차순으로 정렬된다는 것을 알 수 있습니다.

같은 원리로 문자열과 숫자형이 혼합되어 있는 배열의 경우에도 정렬기준이 모두 문자열이라는 가정하에 진행이 됩니다.

그러나 당연히 한 배열에 서로 다른 타입을 혼합하여 갖지 않게 하는 것이 더 중요할 것 같습니다.

🔗 참고자료

| 제목                   | 링크                                                                                     |
| ---------------------- | ---------------------------------------------------------------------------------------- |
| Array.prototype.sort() | https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort |

## 3️⃣ Regexp

### 정규표현식 패턴

- () : 그룹 패턴
- [ ] : 한 글자 패턴
- [^ ] : 부정 문자
- ^: ~으로 시작하는 문자
- &: ~로 끝나는 문자
- .: 어떤 글자
- \d: 숫자
- \w: alphanumeric
- - : 0개 이상
- - : 1개 이상

### 정규표현식 객체 생성

1️⃣ 생성자

```jsx
const re = new RegExp(/@email\.com$/, 'i');
```

RegExp 생성자의 두 번째 인자는 플래그가 들어 옵니다.

2️⃣ 리터럴

```jsx
const re = /@email\.com$/;
```

위의 생성자와 리터럴을 통해 만들어진 RegExp 객체는 서로 같습니다.

🔗 참고자료

| 제목      | 링크                                                                                 |
| --------- | ------------------------------------------------------------------------------------ |
| 한글 검사 | https://eblee-repo.tistory.com/40                                                    |
| RegExp    | https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp |

## 5️⃣ 메소드 네이밍

```jsx
class User {
	getRecommandationUsers(SNSusers, visitors) {
	      const candidates = this.getRecommandationCandidates(SNSusers);
	      const scoreMap = this.getRecommandationScoreMap(candidates);
```

this.getRecommandationCandidates → this.getNotFriends 사실 따지고 보면 `친구 추천이 될만한 후보`는 `해당 유저의 친구가 아닌 모든 SNS 유저`였습니다.

구현의 목적에 따라 클래스의 멤버를 정의하다보니 그 멤버가 갖는 데이터의 본질을 제대로 표현하지 못한 것 같습니다.

그렇게 된다면 해당 메소드는 네이밍만으로 역할을 단정지어줬기 때문에 추천 친구를 구하는 메소드에 종속되어 결합도가 높아지기 때문에 재사용이 불가능할 것입니다.

# 회고

## 1️⃣ 배운 점

1. 정규표현식을 통해 문자열을 구분하는 방법에 대해 알게 되었습니다. 단순히 반복문을 작성하는 코드보다 간결하고 코드 수정도 수월하다고 느껴졌습니다.
2. 마지막 문제인 7번은 객체 지향 class로 접근해보았습니다. 역시 쉽지 않았고 SOLID 원칙이라는 것을 처음 알게 되었습니다.

## 2️⃣ 배울 점

1. 금일 7번까지 마무리한 뒤에 이전 코드를 리팩토링하려했지만 7번 문제 고민과 설계를 하는 데에 하루를 모두 보냈습니다. 7번 문제에서 User라는 클래스를 두어 친구들을 저장하고, 추천친구까지 받아오는 일련의 과정을 한 클래스에 두려고 했습니다. 하지만 코드를 짜면 짤수록 너무 비대해지는 것을 느끼고 더 생각하고 더 찾아보는 계기가 되었습니다.
2. 보다 나은 객체지향 프로그래밍을 해보기 위해 SOLID 원칙을 찾아보았습니다. 그 중에서 제가 코드를 짜면서 제 코드에 불만이었던 부분은 SRP(단일 책임 원칙)입니다. 하나의 클래스는 하나의 책임을 갖고 하나의 actor만 수행해야한다는 것입니다.

   처음 이 내용을 블로그를 통해 접했을 때는 하나의 actor가 하나의 기능(메소드)를 가져야한다고 설명한 글이었습니다. 때문에 과연 이것이 가능한 것인지 더 많은 고민을 하게 되었고, 찾아본 결과 하나의 actor가 하나의 메소드를 뜻하는 것은 아니었습니다.

   쉬운 길을 쫓아 블로그에서 ‘~해야한다’는 조언을 무조건적으로 받아들이지 말아야합니다. 정말 그것이 맞는지 확인해보고 다른 의견은 없는지, 다른 해석은 없는지 찾아봐야겠습니다. 내일은 시간이 더 걸리더라도 더 많이 찾고 읽는 학습을 하겠습니다.
