## 1. 페이지 번호 게임

1. 오른쪽 페이지 - 왼쪽 페이지의 값이 1이 아닐 때 예외처리 // -1
2. 2-3 과정을 통해 나오는 가장 큰 수 도출
3. 비교를 통해 result 반환

## 2. 중복 문자 암호 해독

1. 문자를 배열로 분해
2. 바로 다음에 오는 문자와 현재 문자를 비교하여 같으면 제거하고 함수 재실행(재귀함수)
3. 겹치는 문자가 홀수일 경우 문자 하나가 남는 상황 핸들링 // baaaoat -> boat가 아닌 baoat로 반환됨
4. 겹치는 문자가 없다면 함수 종료

## 3. 3, 6, 9 게임

1. number까지 들어있는 배열 생성 number: 5 -> [1, 2, 3, 4, 5]
2. 숫자를 문자로 변환한 후 각 자리별 문자로 분해 13 -> [1, 3]
3. 각각 숫자를 3으로 나눴을 때 나머지가 0이 되는 요소 -> 1 / 나머지 : 0 [1, 3] -> [0, 1]
4. 0은 3으로 나누어도 나머지가 0이므로 0일 때는 그대로 놔둠
5. 이중 배열 속 합을 구해 맵핑하고 배열의 합을 구해 결과 반환

## 4. 청개구리 사전

1. 아스키 코드로 변환하여 공백일 경우 공백(32) 그대로 출력
2. 대문자일 경우 (아스키 코드가 90이하일 경우) 청개구리 사전의 합이 155인 것을 이용해 반대 스펠링 반환
3. 소문자일 경우 합이 219인 것을 이용하여 반대 스펠링 반환(219 - ascii)

## 5. 화폐 계산기

1. [50000, 10000, 5000, 1000, 500, 100, 50, 10, 1]로 구성된 배열 생성
2. answer = money로 설정한 후 위에 생성한 monetaryUnit로 map 함수를 돌려 몫은 맵핑하고 answer = 나머지로 설정
3. 2번 과정 끝까지 반복

## 6. 같은 글자가 연속적으로 포함된 닉네임 알림

1. forms에 있는 닉네임 두 글자로 쪼개기 '제이슨' => ['제이', '이슨']
2. spread 연산자로 펼친 후 자료구조 Set을 이용해 중복 제거
3. 중복을 제거하기 전 배열에서 중복 제거한 배열을 하나씩 제거
4. 남은 닉네임은 중복되는 것이므로 includes를 통해 중복되는 닉네임 찾기
5. 닉네임으로 이메일을 찾아서 이메일 정렬

## 7. 친구 추천 알고리즘

1. 이미 친구인 사람 + 본인 목록 생성 및 중복 제거 : alreadyFriendList
2. friends 이중 배열 분해 후 alreadyFriendList에 있는 값들 제거
3. 겹치는 갯수 세어서 객체로 생성 {'jongco':30, 'andole': 20}
4. visitor도 위의 객체와 점수 합산 {'jongco':33, 'andole': 22}
5. 점수 별로 나열 후 score가 0인 것 제외해서 배열에 이름 반환
