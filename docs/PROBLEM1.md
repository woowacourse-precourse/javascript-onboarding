## 🚀 기능 요구 사항

포비와 크롱이 페이지 번호가 1부터 시작되는 400 페이지의 책을 주웠다. 책을 살펴보니 왼쪽 페이지는 홀수, 오른쪽 페이지는 짝수 번호이고 모든 페이지에는 번호가 적혀있었다. 책이 마음에 든 포비와 크롱은 페이지 번호 게임을 통해 게임에서 이긴 사람이 책을 갖기로 한다. 페이지 번호 게임의 규칙은 아래와 같다.

1. 책을 임의로 펼친다.
2. 왼쪽 페이지 번호의 각 자리 숫자를 모두 더하거나, 모두 곱해 가장 큰 수를 구한다.
3. 오른쪽 페이지 번호의 각 자리 숫자를 모두 더하거나, 모두 곱해 가장 큰 수를 구한다.
4. 2~3 과정에서 가장 큰 수를 본인의 점수로 한다.
5. 점수를 비교해 가장 높은 사람이 게임의 승자가 된다.
6. 시작 면이나 마지막 면이 나오도록 책을 펼치지 않는다.

포비와 크롱이 펼친 페이지가 들어있는 배열 pobi와 crong이 주어질 때, 포비가 이긴다면 1, 크롱이 이긴다면 2, 무승부는 0, 예외사항은 -1로 return 하도록 solution 메서드를 완성하라.

### 제한사항

- pobi와 crong의 길이는 2이다.
- pobi와 crong에는 [왼쪽 페이지 번호, 오른쪽 페이지 번호]가 순서대로 들어있다.

### 실행 결과 예시

| pobi       | crong      | result |
| ---------- | ---------- | ------ |
| [97, 98]   | [197, 198] | 0      |
| [131, 132] | [211, 212] | 1      |
| [99, 102]  | [211, 212] | -1     |

------------------------------
## [작성자] : 김동우(DongWooKim97)
</br> 

## 📝 구현할 기능 목록
</br> 

### ✔️ 기능 1. 입력값에 대한 유효성 및 에러(예외처리) 검사
<br>

  - 입력값에 에러가 없는지, 입력 양식이 유효한지 검사한지 검사 
	-	에러 존재 / 입력 양식 유효 X -> return -1

	  - 홀수 페이지와 짝수 페이지의 값이 같은지 확인 ```isDuplicate()```<br>

	  - 각 페이지에서 받은 값이 맞는 수인지(홀/짝) 확인 -> ```isNotFitNumber()```<br>

	  - 홀수 페이지와 짝수 페이지의 간격이 1인지 확인 -> ```betweenValue()```<br>

	  - 1 ~ 400 페이지 사이의 값이 입력으로 들어왔는지 확인 -> ```notInRange()```<br>

    
</br>
	

### ✔️ 기능 2. 포비와 크롱의 최댓값 생성 기능
<br>

- 획득한 홀수/짝수 페이지 각 자리수의 합과 곱의 최댓값을 저장.
<br>

    - [13,14] 획득 -> 홀수 페이지의 각 자리의 합/곱 중 최댓값 ```[ (1+3), (1*3) ]``` => ```[ (1+3) ]```
    - [13,14] 획득 -> 짝수 페이지의 각 자리의 합/곱 중 최대값 ```[ (1+4), (1*4) ] => [ (1+4) ]```

- 먼저 각 유저의 배열을 홀수와 짝수로 구분하고, 각 페이지 숫자를 자리수 단위로 구분.
<br>

	- 입력값은 숫자이기에 문자열로 만든 후```split```하여 자리수 단위로 구분. 그리고 계산의 편리성을 위해 다시 자리수 마다 ```map(i => +i)```로 숫자로 변환.
	- ```makeOddNumberString()```과 ```makeEvenNumberString()```로 분리하여 홀/짝수 동시에 진행.
	- 숫자를 각각 배열에 담아 리턴하고 합/곱에 대한 함수의 인자로 전달

<br>

	
- 합하는 경우와 곱하는 경우를 분리하여 생성( ```caseAddNumber()```와 ```caseMultipleNumber()``` 함수 생성)
<br>

  - ```caseAddNumber()```에서는 홀수 페이지의 덧셈 최댓값과 짝수 페이지의 덧셈 최댓값을 비교 /
  - ```caseMultipleNumber()```는 홀수 페이지의 곱셈 최댓값과 짝수 페이지의 곱셈 최댓값을 비교.
    - 각각의 함수에 인자로 입력값인 crong과 pobi라는 배열을 전달 
    - 함수 내에 ```const oddPageAddMaxNumber```와 ```const evenPageAddMaxNumber```를 변수로 생성.
    - 각 로직을 통해 crong과 pobi를 분리하여 리턴.

<br>


### ✔️ 기능 3. 포비와 크롱의 최댓값 비교 기능
<br>

- 기능 2를 통해 얻은 각각의 최댓값을 비교하는 기능 생성
- [13,14] 획득 시, 홀/짝수 페이지의 각각의 합 혹은 곱의 최대값은 [4, 5] -> 이 두 최댓값을 비교하여 유저(크롱/포비)의 최댓값을 설정. 
- ```makeMaxNumber()```에서 나온 리턴값([홀수 최댓값, 짝수 최댓값]) 통해 비교를 진행.
	- ex) ```[72, 72]```가 나왔다 가정하면, 값이 동일하므로 ```return 0```
- ```function compareMaxNumber(maxNumberArray)```은 ```makeMaxNumber()```에서 리턴을 배열로 해주었기 때문에 </br> 
	``` const pobiFinalNumber = maxNumberArray[0]```와 ```const crongFinalNumber = maxNumberArray[1]```로 나누어 포비와 크롱의 최종값을 저장
- 또한 새로운 함수를 생성했기 때문에 리턴값으로 바로 호출하도록 연결(problem()함수에서!)
<br>

```
- ⭕성공한 반환조건⭕
	- 포비의 승리/패배/무승부에 해당하는 3개의 조건문을 통과해야 성공!
	- 각각의 결과가 String값으로 리턴
		- ex) 크롱이 이겼으면 return "fobi"
		- ex) 비겼으면 return "draw"
		- ex) 예외처리 return -1

- ❌실패한 반환조건❌
	- 1번에서 언급한 유효성 검사에서 실패! 
	- checkValid()에서 실패한 결과가 return -1로 반환
		- 홀수 페이지와 짝수 페이지의 값이 같은지 확인 
		- 각 페이지에서 받은 값이 맞는 수인지(홀/짝) 확인 
		- 홀수 페이지와 짝수 페이지의 간격이 1인지 확인
		- 1 ~ 400 페이지 사이의 값이 입력으로 들어왔는지 확인
```



</br>
	

### ✔️ 기능 4. 최대값 비교를 통한 우승자 선발 기능 생성
<br>

- 기능 1 ~ 3을 거친 후, 최종 우승자를 선발하여 리턴함
-	```makeResult()```라는 함수를 생성하여 최종결과(result)를 출력하도록 유도
```
	- 포비가 이겼을 때, return 1
	- 크롱이 이겼을 때, return 2
	- 비겼을 때, return 0
	- 예외 및 유효성 검사 부적격, return -1
```
