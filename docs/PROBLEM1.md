## 🚀 기능 요구 사항

포비와 크롱이 페이지 번호가 1부터 시작되는 400 페이지의 책을 주웠다. 책을 살펴보니 왼쪽 페이지는 홀수, 오른쪽 페이지는 짝수 번호이고 모든 페이지에는 번호가 적혀있었다. 책이 마음에 든 포비와 크롱은 페이지 번호 게임을 통해 게임에서 이긴 사람이 책을 갖기로 한다. 페이지 번호 게임의 규칙은 아래와 같다.

1. 책을 임의로 펼친다.
2. 왼쪽 페이지 번호의 각 자리 숫자를 모두 더하거나, 모두 곱해 가장 큰 수를 구한다.
3. 오른쪽 페이지 번호의 각 자리 숫자를 모두 더하거나, 모두 곱해 가장 큰 수를 구한다.
4. 2~3 과정에서 가장 큰 수를 본인의 점수로 한다.
5. 점수를 비교해 가장 높은 사람이 게임의 승자가 된다.
6. 시작 면이나 마지막 면이 나오도록 책을 펼치지 않는다.

포비와 크롱이 펼친 페이지가 들어있는 배열 pobi와 crong이 주어질 때, 포비가 이긴다면 1, 크롱이 이긴다면 2, 무승부는 0, 예외사항은 -1로 return 하도록 solution 메서드를 완성하라.

### 제한사항

- pobi와 crong의 길이는 2이다.
- pobi와 crong에는 [왼쪽 페이지 번호, 오른쪽 페이지 번호]가 순서대로 들어있다.

### 실행 결과 예시

| pobi       | crong      | result |
| ---------- | ---------- | ------ |
| [97, 98]   | [197, 198] | 0      |
| [131, 132] | [211, 212] | 1      |
| [99, 102]  | [211, 212] | -1     |

### 구현할 기능 목록
1. 예외사항 판별하는 check_valid 함수 구현 :white_check_mark:
- 매개변수 : arr(pobi 또는 crong의 펼친 페이지 배열)
- return값 : isValid (boolean) true 이면 정상, false이면 오류값
- 왼쪽 페이지가 짝수이거나 오른쪽 페이지가 홀수인 경우 오류
- (오른쪽페이지-왼쪽페이지)==1 이 아닌 경우(연속된 페이지가 아닌 경우) 오류
- 페이지가 1~400 사이가 아닌 경우 오류(시작 면이나 마지막 면이 나오도록 책을 펼치지 않는다.)
2. 펼친 페이지의 각 자리 수를 계산하기 위해 자리수를 쪼개는 div_num 함수 구현 :white_check_mark:
- 매개변수 : pobi,crong의 왼쪽 또는 오른쪽 페이지 번호 (정수값)
- return값 : arr(배열) - 받은 숫자의 자리수를 나누어 저장한 배열
3. div_num 함수를 통해 얻은 각 자리수 배열에 대해, 덧셈-곱셈 후 가장 큰 수 구하는 cal_arr 함수 구현 :white_check_mark:
- 매개변수 : arr - 각 자리수 배열
- return값 : bigger - 각 자리수에 대해 덧셈, 곱셈을 진행 후 계산결과 중 더 큰 값(정수값)
4. pobi,crong 의 점수 구하기 :white_check_mark:
- 왼쪽페이지, 오른쪽 페이지에 대해 cal_arr 함수 연산 후, 더 큰 값이 본인의 점수임.
5. pobi,crong 중 승자 구하기 :white_check_mark:
- answer = 1 : 포비가 이기는 경우
- answer = 2 : 크롱이 이기는 경우
- answer = 0 :무승부
- answer = -1 : 예외사항(check_valid 함수 return값이 false 인 경우)
