## 🚀 기능 요구 사항

레벨 2의 팀 프로젝트 미션으로 SNS(Social Networking Service)를 만들고자 하는 팀
이 있다. 팀에 속한 크루 중 평소 알고리즘에 관심이 많은 미스터코는 친구 추천 알고
리즘을 구현하고자 아래와 같은 규칙을 세웠다.

- 사용자와 함께 아는 친구의 수 = 10점
- 사용자의 타임 라인에 방문한 횟수 = 1점

사용자 아이디 user와 친구 관계를 담은 이차원 배열 friends, 사용자 타임 라인 방문
기록 visitors가 매개변수로 주어질 때, 미스터코의 친구 추천 규칙에 따라 점수가 가
장 높은 순으로 정렬하여 최대 5명을 return 하도록 solution 메서드를 완성하라. 이
때 추천 점수가 0점인 경우 추천하지 않으며, 추천 점수가 같은 경우는 이름순으로 정
렬한다.

### 제한사항

- user는 길이가 1 이상 30 이하인 문자열이다.
- friends는 길이가 1 이상 10,000 이하인 배열이다.
- friends의 각 원소는 길이가 2인 배열로 [아이디 A, 아이디 B] 순으로 들어있다.
  - A와 B는 친구라는 의미이다.
  - 아이디는 길이가 1 이상 30 이하인 문자열이다.
- visitors는 길이가 0 이상 10,000 이하인 배열이다.
- 사용자 아이디는 알파벳 소문자로만 이루어져 있다.
- 동일한 친구 관계가 중복해서 주어지지 않는다.
- 추천할 친구가 없는 경우는 주어지지 않는다.

### 실행 결과 예시

| user   | friends                                                                                                                         | visitors                                      | result                    |
| ------ | ------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------- | ------------------------- |
| "mrko" | [ ["donut", "andole"], ["donut", "jun"], ["donut", "mrko"], ["shakevan", "andole"], ["shakevan", "jun"], ["shakevan", "mrko"] ] | ["bedi", "bedi", "donut", "bedi", "shakevan"] | ["andole", "jun", "bedi"] |

### 기능 구현 과정 정리

1. 먼저 사람에 해당하는 Person객체를 생성하였습니다. Person객체는 이름,친구관계
   배열,점수에 해당하는 name,map,score 프로퍼티를 갖습니다

2. 문제에서 주어진 friends,visitors를 받아서 `set`을 이용해 중복을 제거하고, 사
   람의 이름을 뽑아냈습니다. `find_all_person(friends,visitors)`

3. 사람의 이름을 바탕으로 사람 객체를 생성하고, 모든 사람 객체가 들어있는 배열을
   만듭니다. `create_person_obj(set)`

4. 사람-사람간의 친구 관계를 처리하기 위해, `handle_friends`를 실행합니다.
   `handle_friends(모든 사람 객체 배열,친구관계배열)`은 [0],[1]에 해당하는 사람
   을 찾아서 , 첫번째 사람 객체의 map에 두번쨰 사람을,두번쨰 사람 객체의 map에
   첫번째 사람을 넣어줍니다.

5. `find_person_inobj`는 객체 배열 안에서, 이름을 바탕으로 해당하는 사람 객체를
   찾아서 반환합니다.

6. 친구관계를 모두 처리하고, 모든 사람 객체가 들어있는 배열을 돌면서
   `handle_common_friend(모든 사람 객체 배열,사용자)`를 실행합니다.

7. `handle_common_friend`함수는 모든 사람 객체의 사람마다
   `has_common_friend(사람 객체,사용자의 친구관계배열)`을 실행합니다.

8. `has_common_friend(사람 객체, 사용자의 친구관계 배열)`은 사람객체의 map을 순
   회면서 사용자와 함께 아는 친구가 있다면, 사람 객체의 점수를 10점씩 올려줍니다

9. 타임 라인 방문을 다루기 위해,
   `handle_visitors(모든 사람 객체,문제에서 주어진 visitors)`를 실행합니다.

10. `handle_visitors`는 visitors배열의 모든 방문자에 대해 `visite_timeline`을 실
    행합니다.

11. `visite_timeline`함수는 타임라인 방문자의 점수를 1씩 늘려줍니다..

12. `is_friend`함수로 이미 사용자와 친구인 경우 해당 객체의 점수를 0점처리 해주
    었습니다.

13. 마지막 검증으로 `is_valid_person(모든 사람객체,빈 배열,사용자)`를 실행해서
    `점수가 0이 아니고, 최대 5명까지, 사용자가 아닌 사람이면` 배열에 넣고 반환해
    줍니다.

14. 점수순으로 정렬하고, 이름만 뽑아서 최종 답을 구했습니다.
