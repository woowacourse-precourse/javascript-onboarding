## 요구사항 목록

1. problem1.js

- [x] 1. 왼쪽, 오른쪽 페이지 수가 1 이상 나오는 경우 -1을 리턴하도록 예외 처리한다.
- [x] 3. 포비와 크롱의 페이지의 합과 곱을 구하는 함수를 만든다.
- [x] 4. 함수에서 더한 값과 곱한 값 중 큰 수를 리턴한다.
- [x] 2. 포비의 페이지 수가 크면 1, 크롱의 페이지 수가 크면 2, 무승부면 0을 리턴한다.

2. problem2.js

- [x] 1. cryptogram을 배열에 담는 변수와 최종 결과값을 담는 변수를 생성한다.
- [x] 2. 앞, 뒤 값이 같다면 제거하고, 다르다면 answer에 담는다.
- [x] 3. 결과값 안에 또 중복 문자가 있다면 다시 함수를 실행해서 중복을 찾아서 제거한다.
- [x] 4. 더 이상 중복 값이 없다면 결과값을 리턴한다.

3. problem3.js

- [x] 1. 결과값을 담는 변수 answer와 타겟 넘버 3,6,9를 배열에 담은 상수를 만든다.
- [x] 2. 1부터 number까지 숫자를 문자열로 바꾸는 반복문을 만든다.
- [x] 3. 반복문으로 만든 문자열을 인자로 받아 타겟 넘버를 찾는 함수를 만든다.
- [x] 4. 타겟 넘버를 포함하고 있다면 결과값에 담고 리턴한다.

4. problem4.js

- [x] 1. 알파벳 소문자, 대문자 전체와 뒤집은 문자 전체를 담는 변수를 만든다.
- [x] 2. 알파벳 소문자, 대문자 전체 문자와 뒤집은 전체 문자를 만드는 반복문을 만든다.
- [x] 3. 인자 word를 받아 해당하는 뒤집은 알파벳 대소문자를 찾는 함수를 만든다.
- [x] 4. 함수를 불러와서 해당 문자열을 모두 찾으면 결과값을 리턴한다.

5. problem5.js

- [x] 1. 결과값을 담을 변수와 지폐 단위를 담은 상수를 만든다.
- [x] 2. money를 큰 지폐 단위부터 차례로 나눈 몫을 소수점 처리하고 answer에 담는 반복문을 만든다.
- [x] 3. money는 큰 지폐 단위부터 나눈 나머지가 된다.
- [x] 4. 모두 나누고 나면 결과값을 리턴한다.

6. problem6.js

- [x] 1. 결과값, 닉네임, 닉네임을 2글자씩 자른, 닉네임의 중복 카운트를 담는 변수와 이메일을 담고 중복을 제거하는 변수 result를 생성한다.
- [x] 2. forms 1번 인덱스에 있는 닉네임만 추출해 배열에 담는 반복문을 만든다.
- [x] 3. 각 닉네임을 2글자씩 잘라서 변수에 할당하는 반복문을 만든다.
- [x] 4. 닉네임이 중복인지 확인하고 중복이라면 +1, 아니라면 1을 할당해 카운팅한다.
- [x] 5. 카운팅한 중복 개수가 1이 넘는다면 해당 이메일을 result에 담는다.
- [x] 6. result를 오름차순으로 정렬하고 결과값에 할당하고 리턴한다.

7. problem7.js

- [x] 1. 사용자와 함께 아는 친구의 수를 기준으로 추천 점수를 구한다.
- [x] 2. 사용자와 함께 아는 친구 수를 기준으로 추천 점수를 구한다. +10점
- [x] 3. 타임라인에 방문한 횟수를 기준으로 추천 점수를 구한다. +1점
- [x] 4. 두 개를 합산한 추천 점수를 기준으로 오름차순으로 정렬해 결과값에 담아 최대 5명 까지 리턴한다.
- [x] 5. 추천 점수가 0점인 경우는 제외한다.
