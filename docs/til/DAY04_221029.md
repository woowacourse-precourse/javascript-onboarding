# 학습 체크리스트

- [x] OOP
- [x] Map
- [x] Set

# 학습 내용

## 1️⃣ OOP SOLID Principles

### 디자인 패턴

- 디자인 패턴을 적용하는 이유
  - 읽고 이해하기 쉬운 코드를 만들기 위해 사용됩니다.
  - 관리하기 쉽고 테스트하기에 용이하게 만들기 위해 사용됩니다.
  - **주객전도에 주의해야합니다. 디자인 패턴을 적용하기 위해 코드를 더 복잡하게 만들지 않도록 합니다.**
- 디자인 패턴은 다양하며, 상황에 맞는 디자인 패턴을 적용해야 합니다.
- 또한 잘 알려진 23개의 디자인 패턴에 국한되어서 문제를 해결할 필요가 없습니다.
- **즉, 공부한 패턴을 가지고 문제를 해결하려 하지말고, 문제를 제대로 파악하고 효율적인 패턴을 생각하고 고안하는 것이 중요합니다.**

### 1. Single-Responsiblity

**before**

```python
class Cat:
  def __init__(self,age,name):
    self.age = age
    self.name = name

  def eat(self):
    print("eating..")

  def walk(self):
    print("walking..")

  def speak(self):
    print("meow~")

	def print(self):
    return f"name:{self.name}, age:{self.age}"

	def log(self):
    return f"name:{self.name}, age:{self.age}"
```

고양이라는 클래스가 있습니다. eat, walk, speak은 고양이가 하는 행동들이지만, print와 log는 과연 고양이가 하는 행동이라 볼 수 있을까요? 그렇지 않습니다. 때문에 고양이 클래스의 메소드로 적절하지 않습니다. 고양이에게 한 가지의 책임만을 부여해야합니다. (여기서 한 가지는 하나의 메소드를 뜻하는 것이 아닙니다.)

**after**

```python
class Cat:
  def __init__(self,age,name):
    self.age = age
    self.name = name

  def eat(self):
    print("eating..")

  def walk(self):
    print("walking..")

  def speak(self):
    print("meow~")

  def repr(self):
    return f"name:{self.name}, age:{self.age}"

kitty = Cat(3,"kitty")
kitty.eat()
kitty.walk()
kitty.speak()
print(kitty.repr())
#Logger.log(kitty.repr()) ,  If you have the logger object
```

### 2. Open-closed

- 개발 코드(구현부) : 수정에 대해서는 CLOSED
- 클라이언트 코드(실행부) : 확장에 대해서는 OPEN

**before**

```c
class Animal():
  def __init__(self,type):
    self.type = type

def hey(animal):
  if animal.type == 'Cat':
    print('meow')
  elif animal.type == 'Dog':
    print('bark')

bingo = Animal('Dog')
kitty = Animal('Cat')

#Cow와 Sheep을 추가하기위해 hey함수의 수정이 필요하다.

hey(bingo)
hey(kitty)
```

새로운 동물을 추가하여 hey를 실행할 수 없습니다. 왜냐하면 hey 함수에는 고양이와 강아지만을 상정하여 만들어져있기 때문입니다. **이는 실행부에서 cat, dog 외 다른 동물로 확장할 수 없으며, 구현부에서 hey라는 함수를 수정해야하는 문제를 갖는다. 즉 Open-closed 에 위배되는 것입니다.**

**after**

```c
class Animal:
  def speak(self):  #interface method
    pass

class Cat(Animal):
  def speak(self):
    print("meow")

class Dog(Animal):
  def speak(self):
    print("bark")

class Sheep(Animal):
  def speak(self):
    print("meh")

class Cow(Animal):
  def speak(self):
    print("moo")

def hey(animal):
  animal.speak();

bingo = Dog()
kitty = Cat()
sheep = Sheep()
cow = Cow()

hey(bingo)
hey(kitty)
hey(sheep)
hey(cow)
```

### 3. Liskov Substitution

새라는 클래스가 있습니다. 새라면 다 날 수 있겠다는 생각에 새의 메소드로 ‘날다’라는 메소드를 두었습니다. 하지만 펭귄도 새이기 때문에 새의 클래스로 만들어진 인스턴스였지만, 새는 날 수가 없습니다. 위키나 블로그를 보면 이 원칙은 다른 것보다 더 까다롭고 조건이 많은 듯합니다. 상위와 하위 관계에서 서로 교체(치환)할 수 있다는 늬앙스만 기억하는 것이 중요할 것 같습니다.

### 4. Interface segregation

```c
Interface ICarBoatInterface
{
	void drive();
	void turnLeft();
	void turnRight();
	void steer();
	void steerLeft();
	void steerRight();
}

//Interface Segregation Principle
//two small interfaces (Car, Boat)
Interface ICarInterface
{
	void drive();
	void turnLeft();
	void turnRight();
}

Interface IBoatInterface
{
	void steer();
	void steerLeft();
	void steerRight();
}

class Avante : ICarInterface
{
	public void drive()
	{
		//implemenetation
	}
	public void turnLeft()
	{
		//implmementation
	}
	public void turnRight()
	{
		//implementation
	}
}

class CarBoat :ICarInterface , IBoatInterface
{
	public void drive()
	{
		//implemenetation
	}
	public void turnLeft()
	{
		//implmementation
	}
	public void turnRight()
	{
		//implementation
	}
	public void steer()
	{
		//implemenetation
	}
	public void steerLeft()
	{
		//implmementation
	}
	public void steerRight()
	{
		//implementation
	}
}
```

인터페이스의 기능이 너무 많으면, 인터페이스를 받는 클래스에서 필요하지 않는 메소드가 들어오 게 됩니다. 따라서 이를 분리하여 인터페이스를 구성할 수 있도록 합니다.

### 5. Dependency inversion

```python
class Cat:
  def speak(self):
    print("meow")

class Dog:
  def speak(self):
    print("bark")

#Zoo depdns on Cat and Dog
class Zoo:
  def __init__(self):
    self.dog = Dog()
    self.cat = Cat()

  def speakAll(self):
    self.cat.speak()
    self.dog.speak()

zoo = Zoo()
zoo.speakAll()
```

여기서 소와 양을 추가하게 된다면? 더 많은 lowLevel 모듈이 만들어지고, 너무 많은 의존이 생기게 됩니다.

```python
class Animal: #abstract module
  def speak(self): #interface method
    pass

class Cat(Animal):
  def speak(self):
    print("meow")

class Dog(Animal):
  def speak(self):
    print("bark")

#Zoo depends on Animal.   (Not Cat, Not Dog)
class Zoo:
  def __init__(self):
    self.animals = []

  def addAnimal(self,animal):
    self.animals.append(animal)

  def speakAll(self):
    for animal in self.animals:
      animal.speak()

zoo = Zoo()
zoo.addAnimal(Cat())
zoo.addAnimal(Dog())
zoo.speakAll()
```

추상화 모듈 Animal을 만들어서 의존성의 방향을 역전시킵니다.

🔗 참고자료

| 제목                       | 링크                                                                                        |
| -------------------------- | ------------------------------------------------------------------------------------------- |
| 디자인패턴, OOP SOLID 원칙 | https://www.youtube.com/watch?v=jlQkWM7Tu7o&list=PLDV-cCQnUlIZcWXE4PrxJx6U3qKfRTJcK&index=1 |
| 자바스크립트 OOP           | https://velog.io/@teo/Javascript에서도-SOLID-원칙이-통할까                                  |

## 2️⃣ Object VS Map

MDN에서는 Object와 Map 중 어느 것을 사용할지 모를 때 세가지를 고려해볼 것을 권장하고 있습니다.

1. 실행 시까지 키를 알수 없고, 모든 키가 동일한 type이며 모든 값들이 동일한 type일 경우에는 objects를 대신해서 map을 사용해라.
2. key값이 string이 아닌 다른 primitive values를 저장해야할 때 map을 사용해라.
3. 각 개별 요소에 대해 적용해야 하는 로직이 있을 경우에는 objects를 사용해라.

이어서 저 스스로 이 둘 자료구조를 어떤 경우에 써야할지 고민해보았습니다.

`**Object**`

1. value 값의 변동이 많을 경우 (위의 MDN 3번 팁과 동일한 것 같습니다.)

   ```jsx
   //Oject
   peopleObj['ukko'] = 34;

   //Map
   peopleMap.set(peopleMap.get('ukko'), 34);
   ```

   이처럼 Map을 사용하면 set과 get 메소드를 호출해야한다는 것에 부담이 생기기 때문입니다.

2. JSON 객체일 때입니다. JSON.parse() 와 JSON.stringify()는 Map 자료형에는 사용할 수 없습니다.

`**Map**`

1. 안전하게 데이터를 추가, 삭제할 때입니다. key값으로만 set하는 것, 값에 접근을 메소드로 한다는 것이 그렇습니다.
2. key값이 string이 아닌 다른 primitive values를 저장해야할 때입니다. (위의 MDN 2번 팁과 동일한 것 같습니다.)

추가로, 값의 추가에서 Map이 Object보다 성능이 좋다고는 하는데, 이게 그렇게 유의미할 차이를 보이지는 않은 것 같습니다.

🔗 참고자료

| 제목          | 링크                                                                         |
| ------------- | ---------------------------------------------------------------------------- |
| Map Object    | https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Keyed_collections |
| Map vs Object | https://velog.io/@namda-on/JavaScript-Map-과-Object-의-차이                  |

## 3️⃣ Array와 Set

단도직입적으로 말하겠습니다. 이번 과제를 하면서 반복을 제거하기 위해 Set을 사용하는 것 이외에 Set 자료형을 굳이 사용할 필요성을 못 느꼈습니다. 즉, 자료형으로서의 역할을 제대로 할 수 있는지 의문입니다.

제가 7번문제 과제에서 1차원 배열 데이터끼리 교집합과 차집합해야하기 때문에 자료구조를 Set으로 두었습니다. **하지만 자바스크립트에서는 Set 자료형은 연산 메소드를 포함하고 있지 않습니다.** 구글링을 통해 Set 자료형을 연산할 때 사용할 수 있는 함수를 쉽게 찾을 순 있었지만, 이 역시 배열에 적용해도 충분히 가능한 것들이었습니다.

### Set 연산 함수

```jsx
const union = new Set([...setA, ...setB]); // set => array spread syntax 사용
const intersection = new Set([...setA].filter((x) => setB.has(x))); // 둘 다 있는 것들을 솎아낸다.
const difference1 = new Set([...setA].filter((x) => !setB.has(x))); // set1 - set2
const difference2 = new Set([...setB].filter((x) => !setA.has(x))); // set2 - set1
const symmetricDifference = new Set([...difference1, ...difference2]); // union - intersection
```

하지만 보시다싶이 set을 배열로 변환한 다음 filter 동작후에 다시 set으로 변환하는 과정이 포함됩니다. 이럴거면 그냥 배열로 구현하는 게 더 나을 것 같습니다.

🔗 참고자료

| 제목               | 링크                                                                                                           |
| ------------------ | -------------------------------------------------------------------------------------------------------------- |
| set                | https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Set                              |
| set 활용           | https://ibks-platform.tistory.com/398                                                                          |
| set 연산 함수 작성 | https://jun-choi-4928.medium.com/javascript로-set-집합-관련-함수-합집합-교집합-차집합-들-구현하기-e7d4d820b03c |

# 회고

## 1️⃣ 배운 점

- 이전에 잘 사용하지 않던 자료구조(Map, Set)를 사용할 수 있어서 재밌었습니다. 역시 이론적으로 무엇인지 아는 것이랑 직접 써보는 것은 다르다는 것을 한번 더 깨닫게 되었습니다. 막상 써보니 Set의 경우는 필요성을 잘 느끼지 못했고, Map의 경우는 value값을 수정하는 과정에서 코드가 복잡해지는 경험을 했습니다.
- OOP에 대해 공부해보고 7번 문제를 객체지향으로 설계해보려했습니다. 이전에는 함수로만 구현을 하다가 객체지향으로 짜다보니 쉽게 코드를 짤 수 없었고 그만큼 고민하는 시간이 길었습니다. “어떤 객체를 생성해줄 것인가.”, “이 동작은 어느 객체의 메소드로 묶어줘야할까” 고민을 가장 많이 한 것 같습니다. 이 간단한 프로그램에도 머리 아프게 고민을 해야 한다는 것에 놀랍고, 그럼에도 만족스럽지 못한 코드 같아서 OOP의 세계는 쉽지 않다는 걸 느꼈습니다.

## 2️⃣ 배울 점

- 이제 과제를 제출하기 전에 리팩토링을 끝내야합니다. 따라서 클린 코드와 네이밍, 예외처리에 대해 하나씩 공부해야 합니다.
- OOP와 함수형 프로그래밍을 적절히 사용하는 것이 미덕이라고 본 적이 있습니다. 호기심에라도 어떤 식으로 코드가 작성되는지 알아보고 싶습니다. (적용은 별개의 문제지만요.)
