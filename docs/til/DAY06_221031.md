# 학습 체크리스트

- [x] 문제6 중첩 반복문 리팩토링
- [x] 문제7 클래스 리팩토링

# 학습 내용

## 1️⃣ 반복문 리팩토링 (6번)

- **리팩터링**(refactoring):  '결과의 변경 없이 코드의 구조를 재조정함'을 뜻합니다. 프론트엔드 개발자 입장에선 외부 화면은 그대로이지만 내부 논리와 구조를 바꾸어 유지보수와 테스트 검사에 유리하도록 개선하는 것입니다.

### 6번 문제

- 문제 사항
  - 너무 많은 for문으로 인덱스를 쫓아가기 힘들었습니다.
  - for문으로 이어지다 보니 함수로 빼어내어 추상화하기에도 힘들었습니다.
- 해결책
  - for문을 고차함수로 변환한다.
  - 변환된 콜백을 따로 함수로 정의하여 추상화한다.

**before**

```jsx
//구현부
const nicknames = getNicknames(forms);
const getDuplicatedNicknamesEmail = (acc, form, formIndex) => {
  const [currentEmail, currentNickname] = form;

  for (let i = 0; i < form.length; i++) {
    const word = currentNickname.substring(i, i + 2);

    if (word.length !== 2) continue;

    for (let j = formIndex + 1; j < forms.length; j++) {
      const [compareEmail, compareNickname] = forms[j];
      if (compareNickname.includes(word)) {
        acc.add(currentEmail);
        acc.add(compareEmail);
      }
    }
  }
  return acc;
};

//실행부
return [...forms.reduce(getDuplicatedNicknamesEmail, new Set())].sort();
```

**after**

```jsx
//구현부
const findContinuousWord = (twoSizeWords, [email, nickname]) => {
    twoSizeWords.push(
      ...[...nickname]
        .reduce((acc, _, idx) => {
          acc.push(nickname.slice(idx, idx + 2));
          return acc;
        }, [])
        .flat()
    );
    return twoSizeWords;
  };

  const checkValidWord = (words) => {
    return words.length === 2;
  };

  const findEmailsOfDuplicatedNickname = (emailList, twoSizeWord) => {
    const EmailsIncludedWord = forms.reduce((currentList, [email, nickname]) => {
      if (nickname.includes(twoSizeWord)) {
        currentList.push(email);
      }
      return currentList;
    }, []);

    if (EmailsIncludedWord.length >= 2) {
      emailList.push(...EmailsIncludedWord);
      emailList = [...new Set(emailList)];
    }
    return emailList;
  };



//실행부
  return forms
    .reduce(findContinuousWord, [])
    .filter(checkValidWord)
    .reduce(findEmailsOfDuplicatedNickname, [])
    .sort();
}
```

- 결과
  - 실행부분의 로직이 간결하고 보기 쉬워졌습니다.
  - for문을 사용하지 않아 인덱스를 쫓아갈 필요가 없습니다.

그럼에도 반드시 이 방법이 좋다고는 말하지 못하겠습니다. 이유는 for문을 사용하지 않았기 때문에 index 순환을 종료할 수 없었습니다. 따라서 2글자 단어를 추출하는 일에서도 문자열의 마지막까지 반복이 진행되기 때문에 1글자 단어가 포함되는 상황이 발생했습니다.

또한, before코드에서는 전체 크루원의 닉네임을 반복하면서 2글자 단어를 추출하게 되면 앞 사람은 굳이 확인할 필요가 없습니다. 역시 인덱스를 따라 제어했기 때문입니다. 하지만 고차함수를 사용한 이상 모든 요소를 반복해야하기 때문에 이 부분에서 비효율적인 면이 발생했습니다.

🔗 참고자료

| 제목         | 링크                                   |
| ------------ | -------------------------------------- |
| 리팩터링이란 | https://ko.wikipedia.org/wiki/리팩터링 |

## 2️⃣ 클래스 리팩터링

- 처음에는 SNS 클래스를 두어 user, friends, visitors 를 받아 인스턴스를 생성하려 했습니다. 또한 유저에대한 정보를 저장하고 싶었고 이를 SNS 프로퍼티에 두려고 했습니다.
- 문제점: Usermap(유저에 대한 정보)을 프로퍼티로 생성하는데 너무 많은 로직이 필요합니다. 따라서 constructor()내부에 이 많은 것들을 포함할 수 없었습니다.

### constructor에 로직이 비대해진다면?

1. 테스트를 하기 힘들어집니다.
2. **생성만으로 많은 로직이 필요합니다. 모든 인스턴스가 그 프로퍼티가 불필요함에도 말입니다.**
3. 단일책임 원칙에 위배됩니다.

여기서 내 허를 찔렀던 것은 2번 항목입니다. 1번과 3번은 어느정도 예상하고 있었으나 2번, “과연 이것이 클래스의 모든 인스턴스에 반드시 있어야할 프로퍼티인가? 아니면 그저 해당 클래스가 갖고 있어야하는 프로퍼티라는 직감 때문인가?” 저는 후자였던 것 같습니다.

그렇다면 해결책은 크게 세 가지였습니다.

1. userMap이라는 다른 클래스를 두어서 userMap을 클래스 밖에서 생성후 SNS 생성자에 넣을 수 있습니다.
2. getUserMap 이라는 메소드를 만들어서 필요할 때마다 불러올 수 있습니다.

저는 2번으로 문제를 해결하려했습니다. 값은 잘 나오고 프로그램에 문제가 없는듯 하였으나 또 하나의 문제에 봉착했습니다. getUserMap() 메소드가 너무 비대하다는 것입니다. 이를 해결하기 위해 함수로 쪼개어 나누고 싶었지만 과연 그 함수는 어디에 두어야 할까요? 같은 스코프에 있어야한다는 생각에 다음과 같이 SNS 클래스 메소드에 분리하여 두었습니다.

### before

```jsx

class SNS {
	getUserMap() {
	      const userMap = new Map();
	      this.usersFriendRelation.forEach((relation) => {
	        const userId1 = relation[0];
	        const userId2 = relation[1];
	        if (userMap.get(userId1) === undefined) {
	          const userObject = new User(userId1);
	          userMap.set(userId1, userObject);
	        }
	        if (userMap.get(userId2) === undefined) {
	          const userObject = new User(userId2);
	          userMap.set(userId2, userObject);
	        }
	        const userObject1 = userMap.get(userId1);
	        const userObject2 = userMap.get(userId2);
	        userObject1.addFriend(userId2);
	        userObject2.addFriend(userId1);
	        userMap.set(userId1, userObject1);
	        userMap.set(userId2, userObject2);
	}
}
```

### after

```jsx
getUserMap() {
      const userMap = new Map();
      this.setUserMapByUser(this.user, userMap);
      this.friends.forEach((relation) => {
        this.setUserMapByFriends(relation, userMap);
      });
      this.setUserMapByVisitors(visitors, userMap);
      return userMap;
    }

    setUserMapByUser(user, userMap) {
      const userObject = new User(user);
      userMap.set(this.user, userObject);
    }

    setUserMapByFriends([userId1, userId2], userMap) {
      if (userMap.get(userId1) === undefined) {
        const userObject = new User(userId1);
        userMap.set(userId1, userObject);
      }

      if (userMap.get(userId2) === undefined) {
        const userObject = new User(userId2);
        userMap.set(userId2, userObject);
      }

      const userObject1 = userMap.get(userId1);
      const userObject2 = userMap.get(userId2);
      userObject1.addFriend(userId2);
      userObject2.addFriend(userId1);
      userMap.set(userId1, userObject1);
      userMap.set(userId2, userObject2);
    }

    setUserMapByVisitors(visitors, userMap) {
      visitors.forEach((visitor) => {
        if (userMap.get(visitor) === undefined) {
          const visitorObject = new User(visitor);
          userMap.set(visitor, visitorObject);
        }
      });
    }
```

🔗 참고자료

| 제목             | 링크                                                                                    |
| ---------------- | --------------------------------------------------------------------------------------- |
| javscript class  | https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_Classes#constructor |
| 생성자 로직      | https://bb-library.tistory.com/272                                                      |
| 생성자 로직 질문 | https://stackoverflow.com/questions/7048515/is-doing-a-lot-in-constructors-bad          |

# 회고

## 1️⃣ 배운 점

- 이제 곧 일주차 미션이 끝나갑니다. 마무리 단계에서 리팩터링을 시도했고 그 과정에서 내가 평소에서 써오던 코드 습관에 문제점이 있음을 발견했습니다. 그리고 문제점은 때로는 또렷할 때도 있었고 때로는 명확할 때도 있었습니다. 즉, 단순히 직감만으로 잘못되었다고 느낄 때가 있는데 그럴 때마다 검색을 통해 많이 배운 것 같습니다.

## 2️⃣ 배울 점

- 아직도 클래스에 대해서는 무엇이 맞는지 모르겠습니다. 물론 그러니 패턴도 수십가지이고 사람들이 코드에 답이 없다고 말하는 것이라 생각합니다. 내가 코드를 왜 이렇게 쓰고 싶고 어떤 문제점이 있을지를 많이, 정말 많이 생각해 봐야할 것 같습니다.
