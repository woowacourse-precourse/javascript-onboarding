# 1주차 구현 및 학습 정리

> 오늘은 미션의 마지막입니다. 따라서 새롭게 무엇을 배우기보다는 금주를 되돌아보고 배웠던 내용을 정리하는 회고의 내용을 갖으려 합니다. 문제 1~7에서 어떤 로직으로 문제를 풀었고, 어떤 시도를 했는지, 그리고 어떤 점에서 문제가 발생했는지를 위주로 적어보려 합니다.

## 1️⃣ 문제1

### 🌿 로직

1. 주어진 페이지가 유효한지 확인합니다.
   1. 1~400페이지에 있는지
   2. 숫자형인지
   3. 왼쪽이 홀수인지
   4. 두 페이지가 연속인지
2. 포비와 크롱의 스코어 리스트를 구합니다.
3. 그리고 최대 스코어를 구합니다.
4. 포비와 크롱의 최대스코어를 비교하여 점수를 리턴합니다.

### 🌿시도한 점

**`고차함수, 콜백함수 선언`**

배열의 고차함수를 많이 사용하려고 노력했습니다. 이 문제의 경우 reduce를 사용하여 최대값을 구하는 코드를 만들었습니다. 그리고 콜백함수는 별도로 함수로 선언해주어 코드의 가독성을 높이려고 노력했습니다.

### 🌿어려웠던 점과 배운 점

**`네이밍`**

문제1~7까지 전반적으로 해당되는 내용이지만 역시 “네이밍”이 가장 어려웠습니다.처음에는 [firstPage, secondPage] 라고 변수를 설정했습니다. 하지만 책을 중간에 폈을때 첫 페이지, 두 번째 페이지라곤 하지 않습니다. 왼쪽 페이지, 오른쪽 페이지라고 합니다. 이러한 이유로 [leftPage, rightPage]로 변수명을 수정했습니다.

**`문자열 고차함수`**

문자열은 고차함수를 적용할 수 없습니다. 따라서 번거롭지만 스프레드 연산자를 사용하여 배열로 변환한 다음 계산 후에 다시 문자열로 변환하는 작업을 했습니다. 이 부분에서 불필요한 코드가 추가된 것은 아닌지 의문이 들었던 점에서 배열의 고차함수를 쉽게 적용할 수 없었습니다.

## 2️⃣ 문제2

### 🌿로직

1. cryptogram에 대한 유효성 검사를 합니다.
   1. 소문자로만 되어 있어야 있는지
   2. 1~1000의 길이를 가지고 있는지
2. 정규표현식을 사용하여 같은 문자가 있으면 공백으로 변환합니다.

### 🌿시도한 점

**`정규표현식의 재발견과 또 재발견!`**

1. 예외처리할 때 처음에는 길이를 검사하고, 소문자를 검사했습니다. 그러던 중 정규표현식을 사용하면 한번에 할 수 있지 않을까 싶었습니다. ^, &를 통해 처음과 끝을 정해주고 소문자 1개이상 1000개 이하인 문자열을 찾아주어 검사하는 방식으로 하니 깔끔하게 예외처리할 수 있었습니다.
2. 암호를 해독하는 로직에서 처음에는 문자열 슬라이싱으로 했으며 후에는 효율을 위해 스택을 사용했습니다. 하지만 이 역시 정규표현식으로 가능하지 않을까라는 생각으로 폭풍 검색을 했고 다행히 그 해답을 찾을 수 있었습니다.

### 🌿어려웠던 점과 배운 점

**`스택 로직과 정규표현식으로 변환하는 과정`**

문제만 보았을 때는 간단한 문제였는데 막상 요구사항대로 구현하려하니 코드가 더러워지는 현상을 겪었습니다. 단순히 2개만 반복되는 문자가 아니라 연속적인 문자를 제거해주어야 하기 때문에 이에 대한 추가적인 조건 분기가 필요했습니다.

이를 해결하기 위해 정규표현식을 적용했습니다. 그 과정에서 replaceAll 메소드는 노드 버전 15이후라는 명세서를 보고 아차 싶기도 했습니다. 하지만 flag를 global로 두고 replace 메소드를 사용하면 모든 문자에 대해 변환이 가능하다는 것을 알게 되었습니다.

또한 처음 정규표현식을 구현했을 때는 같은 문자가 2번이상 반복되는 패턴을 /a{1,}|b{1,}|c{1,}/ 이런 식으로 모든 알파벳을 하드코딩하려 했습니다. 하지만 그룹을 캡처하는 방식으로 이전 문자 데이터를 기록하여 연속되는 문자를 쉽게 찾을 수 있는 방법을 알게 되었습니다.

## 3️⃣ 문제3

### 🌿로직

1. 유효성검사를 합니다.
   1. number 자료형인지
   2. 1~10000 인지
2. 주어진 숫자를 1까지 하나씩 줄여가면서 3,6,9가 있는지 확인합니다.
   1. 그 과정에서 숫자를 문자열로 변환해야 합니다.

### 🌿시도한 점

**`재귀함수`**

number가 0이 될 때까지 count를 누적해서 더하는 방법으로 구현을 하려 했습니다. 물론 10000까지 가는 숫자 탓에 9000부터 스택 오버 플로우가 발생하여 반복문을 통해 구현했습니다.

### 🌿어려웠던 점과 배운 점

**`꼬리 재귀함수`**

꼬리 재귀함수를 사용하면 스택오버플로우가 발생하지 않은 줄 알았습니다. 꼬리 재귀 함수란 return 표현식에 자신의 함수를 호출하는 것 외에 다른 연산자를 붙이지 않는 함수입니다.

블로그마다 늬앙스가 조금씩 달라서 정확히는 모르겠지만 분명 꼬리 재귀함수로 구현했음에도 에러가 발생했습니다. 이 점을 보아 꼬리 재귀가 스택오버 플로우를 발생시키지 않는 로직이라는 것이 아니라 다른 연산자를 제거함으로써 실수를 줄여줄 수 있다는 뜻인 것 같습니다.

## 4️⃣ 문제4

### 🌿로직

1. 유효성 검사를 합니다.
   1. 문자열인지
   2. 단어의 길이가 1부터 1000이하인지 확인합니다.
2. 단어의 철자를 순회하면서 알파벳 소문자,대문자이면 반대 문자로 변환합니다.
   1. 아스키 코드를 사용하면 반대편 문자를 쉽게 구할 수 있습니다.

### 🌿배운 점

**`전역 변수(상수)로 저장`**

4번 역시 1~3번에서 시도했던 것들을 똑같이 시도했습니다. 네이밍, 상수표현, 고차함수, 콜백 분리 등 말입니다. 그중에서도 이번 문제에서 가장 배운 것은 상수(전역변수)로 표현했을 때 장점이 가장 잘 드러났습니다. 소문자와 대문자일 때의 아스키코드를 변수로 저장을 하니 알파벳을 반대로 전환하는 과정에서 로직이 더욱 명확해졌습니다.

1️⃣

```jsx
String.fromCharCode(155 - characterAscii);
```

2️⃣

```jsx
String.fromCharCode(MIN_UPPER_ALPHABET_ASCII + MAX_UPPER_ALPHABET_ASCII - characterAscii);
```

전자의 경우는 155가 무엇을 뜻하는지를 모릅니다. 이 문제의 핵심인데도 코드를 읽는 사람이 명확하게 어떤 로직인지 파악하기 힘듭니다. 하지만 후자의 경우는 무엇을 더했고 뺐는지 명확합니다.

## 5️⃣ 문제5

### 🌿로직

1. 유효성 검사를 합니다.
   1. 주어진 money 가 1이상 1000000이하인지
2. 출금할 돈을 화폐로 전환합니다.
   1. 화폐 종류를 큰 액수부터 정렬된 배열을 하나씩 접근합니다.
   2. 돈을 화폐 종류로 나눈 수만큼 결과값에 기입합니다.
   3. 남은 돈을 통해 다음 화폐에서 확인하는 절차를 진행합니다.

### 🌿배운 점

`네이밍`

4번과 마찬가지로 평소 코딩테스트 준비를 하면서 풀었던 문제라 크게 어려운 점은 없었습니다. 그럼에도 배울 수 있었던 것은 역시 네이밍입니다. 화폐를 money로 써야할지 currency로 써야할지부터 화폐 종류는 어떻게 표기를 해야할지 고민을 많이했습니다. 결론은 구글링! 한국조폐공사 홈페이지에 들어가서 영어를 선택하여 적절한 어휘를 찾을 수 있었습니다. 영어표현이 진짜 모르겠을 때는 관련된 내용이 있는 공식홈페이지에 들어가서 영어버전으로 하여 확인하는 것도 좋은 방법인 것 같습니다.

## 6️⃣ 문제6

### 🌿로직

1. forms 유효성 검사를 합니다.
   1. 이메일 검사
   2. form검사
   3. 닉네임 검사
2. 전체 닉네임에서 두글자 단어를 모두 추출합니다.
3. 추출된 두글자 단어를 순회하며 해당 단어를 갖는 크루가 2명 이상이면 이메일을 기록합니다.
4. 기록된 이메일에서 중복을 제거합니다.
5. 오름차순으로 정렬 후에 값을 반환합니다.

### 🌿시도한 점

**`고차함수의 메소드 체이닝`**

처음에는 각 개인 별로 순회하면서 해당 크루의 닉네임에서 두 글자를 추출하고 배열의 그 다음 인덱스부터 해당 단어가 포함되는지 확인하는 방식이었습니다.

그러나 이러한 방식이 효율적으로 보일 순 있으나 따로 함수로 분리하기에도 힘들며, 인덱스를 계속 쫓아야되어서 가독성이 매우 떨어집니다.

그래서 시도한 것이 단계별로 과정을 나누어서 반복문을 실행시켰습니다. 그러다보니 자연스레 고차함수를 사용할 수있게 되었습니다. **더 나아가 실행부에서 forms를 메소드 체이닝만으로 로직을 표현할 수 있지 않을까?** 라는 생각을 했고 생각보다 수월하게 완성시킬 수 있었습니다.

### 🌿어려웠던 점과 배운 점

**`고차함수의 메소드 체이닝`**

고차함수의 메소드 체이닝이 좋은 코드인지 확신이 안섭니다. 왜냐하면 고차함수를 사용했기 때문에 로직을 읽으려면 **“고차함수의 종류 + 콜백 함수의 기능”**을 조합하여 의미를 해석해야하기 때문입니다. 그래서 고차함수를 다시 함수로 정의할까도 생각을 했습니다. 하지만 평소와 다르게 고차함수 메소드 체이닝을 사용한 것을 남겨서 피드백 받고 싶은 마음에 그대로 보존하기로 했습니다.

**`고차함수 범위 지정의 문제`**

고차함수를 사용할 때 index의 시작과 끝을 마음대로 정할 수 없습니다. 이로 인해 두 글자만 추출해야하는 과정에서 마지막 글자(한 글자)를 제외시키지 못하고 포함시켜야하는 상황이 생겼습니다. 이를 해결하기 위해 filter을 사용해서 해결했습니다. 하지만 부차적인 로직이 추가됨에 따라 실행부에서 다소 로직이 불명확해지는 부작용이 생긴 것 같습니다.

## 7️⃣ 문제7

### 🌿로직

1. 유효성 검사
   1. 이름 검사
   2. 친구목록 검사
   3. 방문자 검사
2. 이용자와 이용자에 따른 친구를 저장합니다.
3. 이를 바탕으로 추천 시스템을 실행합니다.
   1. 내 친구와 친구의 친구가 서로 알고 있는지 확인하여 점수를 측정합니다.
   2. 방문자를 확인하여 점수를 측정합니다.
4. 점수가 합산된 결과를 정렬하여 최대 5명의 추천친구를 소개합니다.

### 🌿시도한 점

**`내가 마크주커버라는 생각으로!`**

내가 마크주커버라면… 이 프로그램의 기능이 친구를 추천해주는 기능만 있진 않을 것입니다. SNS 라는 하나의 시스템 아래에서 여러 기능이 있을 것입니다. 그렇기 때문에 한 유저가 갖고 있는 친구 목록은 굉장히 자주 쓰일 데이터입니다. 따라서 문제 요구 조건만 구현하면 굳이 다른 유저들의 친구 목록까지 저장할 필요는 없음에도 저장해두었습니다.

**`객체 지향 구현`**

내가 마크주커버라는 생각에 그만 해선 안될 행동을 했습니다. 이왕 이렇게 된거 객체지향으로 작성해서 만약에 다른 기능이 추가될 수 있음을 고려하여 객체를 나누고 해당 프로퍼티와 메소드를 작성했습니다. 또한 추천시스템의 로직도 언제든 추가되고 수정될 수 있을 거라는 고려 하에 하나의 객체로 두어 메소드를 실행시키는 방식으로 구현했습니다.

### 🌿어려웠던 점과 배운 점

**`객체 지향`**

처음 짜보는 객체 지향이다 보니 어려운 점이 많았습니다.

1. 어떤 객체를 만들어야 하는가
2. 해당 로직은 누구의 객체의 몫인가
3. 객체 메소드 내의 로직에 대한 함수 분리는 어떻게 하는가
4. constructor에 많은 로직을 담아도 되는가
5. static으로 구현해도 사용하는 데 문제가 없었는데 어떨 때 static 키워드를 사용하는가

아주 기초적인 내용, SOLID원칙만 공부한 후에 OOP를 구현하려다보니 여러 문제점에 봉착했습니다. 7번 문제가 다른 문제보다 복잡한 것도 있지만 객체지향을 적용하려다 보니 가장 많은 시간을 쏟은 문제였습니다. 짜고 나서 아무리 봐도 이게 좋은 코드 같진 않아 보였습니다. 후에 객체지향을 더 공부하고 크루들과 같이 이야기 나누면서 지식을 더 쌓은 후에 무엇이 문제였는지 다시 찾아보고 싶은 문제입니다.

# 1주차 회고

빨리 내일이 왔으면 좋겠습니다. 커뮤니티가 열리고 다른 사람의 코드를 보면서 서로 이야기를 나누고 싶어서 입이 간질 간질합니다. 제가 짠 코드를 보고 다른 사람은 어떻게 평가할 지, 다른 사람은 어떤 다양한 시도를 했는지 궁금합니다. 지금도 슬랙에서 다른 크루분들끼리 서로 질문하고 답변하시는 것 같지만, 오리엔테이션에서 포비님이 말씀하셨듯 일단 스스로 해결해보라는 조언에 그렇게 하고 있습니다. 실제로 다른 사람의 답만 쫓아서 공부했다면 ‘정규표현식’, ‘고차함수를 메소드 체이닝’, ‘객체지향 구현’ 이런 다양한 시도는 하지 않았을 것 같습니다.

1주차는 제가 짜던 코드가 좋은 코드였는지 여러가지로 회의적으로 생각해볼 수 있었던 시간이었습니다. 앞서 말했듯 여러가지 시도를 해보면서 과연 이전에 짜던 코드 스타일이 더 낫다고 말할 수 있나? 라는 질문을 많이 했습니다. 결론은 “뭐가 더 나은지 모르겠다!” 그냥 문제에 적합해보이는 걸로 시도를 해봤을 뿐입니다.

1주차는 많이 생각해볼 시간을 가졌던 것과 더불어 많이 체험하고 배울 수 있었습니다. git을 처음으로 이렇게 많이 사용해보았습니다. 이전에 작성했던 커밋 메세지를 수정하는 일도 생겼고, 이미 스테이지 올렸던 데이터를 추가하여 저장하는 일도 생겼습니다. 그 과정에서 stash도 사용해볼 수 있었습니다. 이론으로만 git을 공부할 때는 너무 복잡해 보였는데 막상 필요해서 구글링 하다보니 그렇게 어려운 녀석도 아니었던 것 같습니다.

git뿐만 아니라 자바스크립트도 많이 배웠습니다. 아니 정확히 말하면 코드 작성 실행력을 많이 배운 것 같습니다. 이론으로는 자바스크립트 문법에 이런 것들이 있다라고 많이 배워왔습니다. 하지만 사용하지 않았습니다. 익숙한 것들만 사용했습니다. 그러나 이번에는 익숙치 않은 문법을 많이 사용했습니다. 익숙치 않은 문법을 사용하면 세상이 무너지는 것도 아닌데 과거의 나는 왜 그랬는지 모르겠습니다! 실제로 자바스크립트 검색을 여러가지 해보면서 적용하고 이전의 코드와 비교하는 일을 일상처럼 하다보니 자바스크립트 코드 작성 실행력을 얻은 것 같습니다.
