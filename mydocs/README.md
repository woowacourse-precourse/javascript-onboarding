# 기능 구현 목록

## problem 1

0. 예외 상황

- 페이지가 연속적이지 않은 경우
- 시작 면이나 마지막 면이 나오도록 책을 펼치는 경우
- 페이지가 1 - 400 사이가 아닌 값이 들어오는 경우 예외 처리
- 책을 살펴보니 왼쪽에는 홀수, 오른쪽에는 짝수였으므로 홀짝에 대한 판단은 안해도 된다고 생각됨

1. 왼쪽 페이지 번호

- 페이지의 각 자리수를 더한 값 구하기
- 페이지의 각 자리수를 곱한 값 구하기
- 둘 중 더 큰 값 구하기

2. 오른쪽 페이지 번호

- 페이지의 각 자리수를 더한 값 구하기
- 페이지의 각 자리수를 곱한 값 구하기
- 둘 중 더 큰 값 구하기

3. 1,2번 중 더 큰 수 구하기

4. 두 사람이 1,2,3번 과정을 통해 얻은 값 비교

- 포비가 크면 1
- 크롱이 크면 2
- 같으면 0
- 예외상황은 -1

## problem 2

0. 제한 사항 조건 처리

- cryptogram의 길이는 1 이상 1000 이하일 것
- 알파벳 소문자로만 이루어질 것

1. 연속되는 문자열 찾기

- 2회 이상 연속으로 입력되어있는 문자열을 찾는다

2. 연속되는 문자열 삭제하기

- 이어지는 문자열들을 전부 삭제한다

3. 2번 결과에 대하여 1번에 해당하는 것이 없을 때까지 위 과정을 반복한다

4. 더 이상 반복할 수 없다면 결과를 반환한다

## problem 3

1. 1부터 number까지의 숫자 중 3,6,9가 들어가는 숫자를 찾는다.

2. 해당 숫자의 3,6,9 개수만큼 손뼉 카운트를 증가시킨다.

- ex) 99라면 9가 2번 들어갔으므로 손뼉 카운트는 2 증가한다.

3. 연산이 완료된 손뼉 카운트를 반환한다.

## problem 4

1. 입력받은 word를 배열로 변환

2. 주어진 규칙에 따라 알파벳 변경

- 알파벳 소문자는 소문자로, 대문자는 대문자로 변경한다
- 아스키 코드 활용

3. 변환이 완료된 배열을 하나의 문자열로 만들어서 반환

## problem 5

1. 원금을 큰 금액 화폐를 위주로 나눈다.

- 원금을 오만, 만, 오천, 천, 오백, 백, 오십, 십, 일 원 단위로 순서로 나눈다

2. 1번에서 구한 (몫 \* 화폐 단위)를 원금에서 뺀다

3. 몫은 정답 배열에 넣는다

- 이 때, 배열은 오만, 만, 오천, 천, 오백, 백, 오십, 십, 일 원 순서여야한다.

4. 나머지 금액에 대하여 나누기 연산을 반복한다

5. 금액이 0이 될 때까지 나누기를 진행한다.

6. 연산이 종료된 정답 배열을 반환한다.

## problem 6

0. 제한 사항 만족 여부 판단

- 이메일은 11자 이상 20자 미만일 것
- 이메일의 @ 문자 뒤는 email.com일 것
- 닉네임은 1자 이상 20자 미만일 것

1. 입력받은 닉네임 간 중복이 있는지 판별하기

- 두 글자 이상의 문자가 연속적으로 순서에 맞춰 포함되어있는가?
- 기준이 되는 닉네임을 선정한다
- 앞에서부터 두 글자씩 잘라서 중복 판별할 단어를 설정한다
- 다른 닉네임에 해당 단어가 포함되는지 여부를 판단한다
- 앞에서부터 세 글자씩 잘라서 중복 판별할 단어를 설정한다
- 다른 닉네임에 해당 단어가 포함되는지 여부를 판단한다
- 이런 식으로 기준 닉네임의 길이만큼 자르는 범위를 늘려가며 연산한다
- 하나의 닉네임에 대하여 판별이 끝나면, 다음 닉네임을 기준으로 삼고 위 과정을 반복한다.

2. 결과 배열에는 이메일만 들어간다

- 중복을 제거할 것
- 문자열을 오름차순 정렬할 것

## problem 7

0. 제한 사항 만족 여부 판단

- user는 길이가 1 이상 30 이하일 것
- 사용자의 아이디는 소문자로만 이루어져 있을 것
- friends에 들어가는 모든 유저는 길이가 1 이상 30 이하일 것

1. user와 친구인 사람들을 찾는다

- friends 배열 원소인 1차원 배열에 대하여 includes 사용

2. 1번에서 찾은 사람들과 친구인 사람들을 찾는다

- user가 포함된 배열은 제외할 것
- 1차원 배열에 대하여 includes 사용
- 찾은 이들의 점수를 10 올린다

3. visitors 배열 연산

- 방문한 사람의 점수를 1 올린다
- 중복이 허용된다. 많이 방문하면 그 사람은 점수가 계속 추가된다

4. 친구들의 점수를 합산한다

5. 결과를 배열 형태로 출력한다

- 배열 길이는 5 이하로 한다
- 4번에서 구한 점수가 0이면 배열에 넣지않는다
- 4번에서 구한 점수가 동점이라면 이름순으로 정렬한다
- 이미 친구인 사람은 넣지 않는다

# 수정 사항

## 주석 관련

1. 가능한 주석은 최소한으로 하자

## problem 1

1. 페이지가 1 - 400 사이가 아닌 값이 들어오는 경우 예외 처리(완료)
2. if else문 ==> if문(완료)

## problem 2

0. 제한 사항 조건 처리

- cryptogram의 길이는 1 이상 1000 이하일 것(완료)
- 알파벳 소문자로만 이루어질 것(완료)

1. 연속된 문자가 3개 이상일 경우에 대한 처리(완료)

- 스택을 활용하는게 더 나을지는 더 고민해보자.

2. if else문 ==> if문(완료)

## problem 3

1. 모든 숫자에 대하여 3,6,9 판단을 하지말자(파기)

- 3,6,9 계산을 하기 전에 3,6,9가 포함된 숫자인지를 미리 판별한다(완료)
- 판별 결과가 참인 것들만 연산을 진행하고, 거짓인 경우 continue로 다음 숫자로 넘어간다(완료)

2. 테스트 결과나 코드 흐름으로 봤을 때, 굳이 검사를 해줄 필요가 없다(완료)

- 시간을 더 잡아먹기 때문이다.
- includes를 사용했는데, 이로 인해서 소요 시간이 오히려 증가해버렸다.

## problem 4

1. 문자열의 길이가 1 이상 1000 이하일 것(완료)

2. 알파벳과 공백 이 외에 다른 문자들이 들어올 수 있다(완료)

- 아스키 코드를 활용해서 알파벳만을 변환하고, 공백과 다른 문자들은 그대로 놔둔다.(완료)

3. 정규식과 아스키 코드 비교 중 어떤 것이 더 나은지 고민해보자.(완료)

- 알파벳인지 아닌지 판별에 사용하는 부분에서.(완료)
- 정규식을 사용하는게 더 빠름.
- 아스키코드는 소요시간 변동이 있는 반면, 정규식은 비교적 안정적

## problem 5

1. money는 1 이상 1,000,000 이하인 자연수 일 것(완료)

## problem 6

0. 입력 데이터 제한 사항

- forms 배열의 길이가 1 이상 10000 이하 일 것(완료)
- 닉네임은 한글만 가능하다(완료)

1. 리팩토링 필수(보류)

2. 함수가 너무 연결되어있으므로, 최대한 연결 고리를 끊어내는 방향으로 다시 고민해보자(보류)

3. 다른 중복 단어에 의해 여러 명이 걸렸을 경우에 대한 케이스 실험(완료)

4. 이메일에서 10자는 "@email.com"으로 이미 채워져있음에 주의(완료)

## problem 7

0. 입력 데이터 제한 사항

- user의 길이는 1 이상 30 이하일 것(완료)
- friends 배열의 길이는 1 이상 10000 이하일 것(완료)
- friends의 각 원소(아이디)는 길이가 1 이상 30 이하일 것(완료)
- visitors의 길이는 0 이상 10000 이하일 것(완료)
- 모든 이의 아이디는 소문자로만 이루어질 것(완료)

1. if else문 => if문(완료)

2. indent를 줄여보자(완료)

3. for in => 다른 반복문 사용하자(완료)

- for in 성능 문제에 대한 얘기가 많다
- 대안. Object.entries() 사용
- 비교 결과. for in보다 Object.entries()가 더 빠른 성능을 가진다.
- 케이스별 편차가 다소 존재하지만, 더 빠른 경우가 많기 때문에 변경하는 것으로 결정.

## 고민

- 함수는 최소한의 기능을 하도록 만드는 것이 좋다고한다
- 그렇다면, 어느정도 사소한 기능까지가 함수 모듈화로 이득을 볼 수 있을까?
- 너무 세세하게 분리를 하면 성능에는 문제가 없나?
- 몇 겹의 for문을 안쪽에서부터 차례대로 함수화한다고 하면, for문을 분리한 것일 뿐인데 좋은 코드인가?

- 소문자/대문자 판별 정규식 전면 수정 필요!!!!!!!
- test() 메서드만 사용하고 있기 때문에 g가 붙을 필요는 없을 것 같다
- /^[a-z]+$/ 소문자로만 이루어진 문자
- /^[A-Z]+$/ 대문자로만 이루어진 문자
- /^[a-z|A-Z]+$/ 소문자 혹은 대문자로만 이루어진 문자

- for 문이 성능 상 기타 반복 연산 메소드에 비해 좋기 때문에 메소드 사용을 최대한 줄였는데
- 너무 사용하지 않는 것은 코드를 깔끔하게 만드는데 방해가 될 수도 있겠다
- 현재 유의미한 성능 차이가 있나?
