# 기능 구현 목록

## problem 1

0. 예외 상황

- 페이지가 연속적이지 않은 경우
- 시작 면이나 마지막 면이 나오도록 책을 펼치는 경우

1. 왼쪽 페이지 번호

- 페이지의 각 자리수를 더한 값 구하기
- 페이지의 각 자리수를 곱한 값 구하기
- 둘 중 더 큰 값 구하기

2. 오른쪽 페이지 번호

- 페이지의 각 자리수를 더한 값 구하기
- 페이지의 각 자리수를 곱한 값 구하기
- 둘 중 더 큰 값 구하기

3. 1,2번 중 더 큰 수 구하기

4. 두 사람이 1,2,3번 과정을 통해 얻은 값 비교

5. 포비와 크롱의 값 비교

- 포비가 크면 1
- 크롱이 크면 2
- 같으면 0
- 예외상황은 -1

## problem 2

1. 연속되는 문자열 찾기

- 2회 이상 연속으로 입력되어있는 문자열을 찾는다

2. 연속되는 문자열 삭제하기

- 이어지는 문자열들을 전부 삭제한다

3. 2번 결과에 대하여 1번에 해당하는 것이 없을 때까지 위 과정을 반복한다

4. 더 이상 반복할 수 없다면 결과를 반환한다

## problem 3

1. 1부터 number까지의 숫자 중 3,6,9가 들어가는 숫자를 찾는다.

2. 해당 숫자의 3,6,9 개수만큼 손뼉 카운트를 증가시킨다.

- ex) 99라면 9가 2번 들어갔으므로 손뼉 카운트는 2 증가한다.

3. 연산이 완료된 손뼉 카운트를 반환한다.

## problem 4

1. 입력받은 word를 배열로 변환

2. 주어진 규칙에 따라 알파벳 변경

- 알파벳 소문자는 소문자로, 대문자는 대문자로 변경한다
- 아스키 코드 활용

3. 변환이 완료된 배열을 하나의 문자열로 만들어서 반환

## problem 5

1. 원금을 큰 금액 화폐를 위주로 나눈다.

- 원금을 오만, 만, 오천, 천, 오백, 백, 오십, 십, 일 원 단위로 순서로 나눈다

2. 1번에서 구한 (몫 \* 화폐 단위)를 원금에서 뺀다

3. 몫은 정답 배열에 넣는다

- 이 때, 배열은 오만, 만, 오천, 천, 오백, 백, 오십, 십, 일 원 순서여야한다.

4. 나머지 금액에 대하여 나누기 연산을 반복한다

5. 금액이 0이 될 때까지 나누기를 진행한다.

6. 연산이 종료된 정답 배열을 반환한다.

## problem 6

0. 제한 사항 만족 여부 판단

- 이메일은 11자 이상 20자 미만일 것
- 이메일의 @ 문자 뒤는 email.com일 것
- 닉네임은 1자 이상 20자 미만일 것

1. 입력받은 닉네임 간 중복이 있는지 판별하기

- 두 글자 이상의 문자가 연속적으로 순서에 맞춰 포함되어있는가?
- 기준이 되는 닉네임을 선정한다
- 앞에서부터 두 글자씩 잘라서 중복 판별할 단어를 설정한다
- 다른 닉네임에 해당 단어가 포함되는지 여부를 판단한다
- 앞에서부터 세 글자씩 잘라서 중복 판별할 단어를 설정한다
- 다른 닉네임에 해당 단어가 포함되는지 여부를 판단한다
- 이런 식으로 기준 닉네임의 길이만큼 자르는 범위를 늘려가며 연산한다
- 하나의 닉네임에 대하여 판별이 끝나면, 다음 닉네임을 기준으로 삼고 위 과정을 반복한다.

2. 결과 배열에는 이메일만 들어간다

- 중복을 제거할 것
- 문자열을 오름차순 정렬할 것

## problem 7

0. 제한 사항 만족 여부 판단

- user는 길이가 1 이상 30 이하일 것
- 사용자의 아이디는 소문자로만 이루어져 있을 것
- friends에 들어가는 모든 유저는 길이가 1 이상 30 이하일 것

1. user와 친구인 사람들을 찾는다

- friends 배열 원소인 1차원 배열에 대하여 includes 사용

2. 1번에서 찾은 사람들과 친구인 사람들을 찾는다

- user가 포함된 배열은 제외할 것
- 1차원 배열에 대하여 includes 사용
- 찾은 이들의 점수를 10 올린다

3. visitors 배열 연산

- 방문한 사람의 점수를 1 올린다
- 중복이 허용된다. 많이 방문하면 그 사람은 점수가 계속 추가된다

4. 친구들의 점수를 합산한다

5. 결과를 배열 형태로 출력한다

- 배열 길이는 5 이하로 한다
- 4번에서 구한 점수가 0이면 배열에 넣지않는다
- 4번에서 구한 점수가 동점이라면 이름순으로 정렬한다
- 이미 친구인 사람은 넣지 않는다

# 수정 사항

## 주석 관련

1. 가능한 주석은 최소한으로 하자

## problem 1

1. 페이지가 1 - 400 사이가 아닌 값이 들어오는 경우 예외 처리(완료)
2. if else문 ==> if문(완료)

## problem 2

1. 연속된 문자가 3개 이상일 경우에 대한 처리

- 스택에 들어갈 다음 문자가 스택 가장 위 값과 같은지 판별하는게 아니라, 다음 다음 문자가 다른지 같은지도 판단해야함
- 예를들어, 스택에 [1,2,3]이 있고 앞으로 들어갈 값이 [3,3,4,2,1]이라고 하면
- 스택의 3과 들어갈 3이 같으면 스택에 넣고, 그 다음 수를 판별
- 또 3이 들어오므로 스택에 넣고, 그 다음수 판별
- 4라는 다른 값이 들어오므로 그 때 3을 전부 삭제

방법 2

- 스택의 가장 뒤와 지금 들어갈 문자가 일치하지 않으면 스택에 넣는다
- 스택에 들어간 문자열의 인덱스를 변수에 저장해놓는다.
- 스택의 가장 뒤와 지금 들어갈 문자가 일치한다면 continue로 다음 문자로 넘어간다.
- 스택의 가장 뒤와 지금 들어간 문자가 일치하지 않을 때까지 continue가 진행된다.
- continue가 실행되지 않고, 스택에 들어가야한다면, 이 때 들어갈 문자열의 인덱스를 변수에 저장한다.
- 2번째에서 구한 인덱스와 지금 구한 인덱스가 1의 차이가 나는게 아니라면
- 스택에 있는 값을 pop하고, 지금 들어갈 문자를 스택에 push한다

2. if else문 ==> if문

## problem 3

1. 모든 숫자에 대하여 3,6,9 판단을 하지말자(파기)

- 3,6,9 계산을 하기 전에 3,6,9가 포함된 숫자인지를 미리 판별한다(완료)
- 판별 결과가 참인 것들만 연산을 진행하고, 거짓인 경우 continue로 다음 숫자로 넘어간다(완료)

2. 테스트 결과나 코드 흐름으로 봤을 때, 굳이 검사를 해줄 필요가 없다(완료)

- 시간을 더 잡아먹기 때문이다.
- includes를 사용했는데, 이로 인해서 소요 시간이 오히려 증가해버렸다.

## problem 4

1. 문자열의 길이가 1 이상 1000 이하일 것(완료)

2. 알파벳과 공백 이 외에 다른 문자들이 들어올 수 있다(완료)

- 아스키 코드를 활용해서 알파벳만을 변환하고, 공백과 다른 문자들은 그대로 놔둔다.(완료)

## problem 5

1. money는 1 이상 1,000,000 이하인 자연수 일 것(완료)

## problem 6

0. 입력 데이터 제한 사항

- forms 배열의 길이가 1 이상 10000 이하 일 것(완료)
- 닉네임은 한글만 가능하다(완료)

1. 리팩토링 필수(보류)

2. 함수가 너무 연결되어있으므로, 최대한 연결 고리를 끊어내는 방향으로 다시 고민해보자(보류)

## problem 7

0. 입력 데이터 제한 사항

- user의 길이는 1 이상 30 이하일 것(완료)
- friends 배열의 길이는 1 이상 10000 이하일 것(완료)
- friends의 각 원소(아이디)는 길이가 1 이상 30 이하일 것(완료)
- visitors의 길이는 0 이상 10000 이하일 것(완료)
- 모든 이의 아이디는 소문자로만 이루어질 것(완료)
