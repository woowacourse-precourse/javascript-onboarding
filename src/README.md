## 목차

- [Problem 1](#-problem-1)
- [Problem 2](#-problem-2)
- [Problem 3](#-problem-3)
- [Problem 4](#-problem-4)
- [Problem 5](#-problem-5)
- [Problem 6](#-problem-6)
- [Problem 7](#-problem-7)

## 🔖 PROBLEM 1

### 제한사항

- 책은 1페이지부터 400페이지까지 있다.
- 왼쪽페이지는 홀수, 오른쪽페이지는 짝수이다.
- 시작 면이나 마지막 면이 나오도록 책을 펼치지 않는다.

### 기능 요구 사항

- 예외사항은 -1을 return 한다.
- 포비가 이긴다면 1, 크롱이 이긴다면 2, 무승부는 0을 리턴한다.

### 체크포인트

- [o] 입력 예외사항을 캐치하는 함수를 만든다.
- [o] 한 페이지의 가장 높은 점수를 리턴하는 함수를 만든다.
- [o] 두 페이지를 비교해 점수를 확정하는 함수를 만든다.
- [o] 최종적으로 problem1 함수를 완성해준다.

### 학습메모

## 🔖 PROBLEM 2

### 기능 요구 사항

- 연속하는 중복 문자열을 삭제한 결과를 리턴한다.
- 중복문자열을 제거할 수 없을 때까지 반복한다.

### 제한사항

- cryptogram은 길이가 1 이상 1000 이하인 문자열이다.
- cryptogram은 알파벳 소문자로만 이루어져 있다.

### 체크포인트

- [o] stack을 이용해 중복을 제거하는 로직구현

### 학습메모

## 🔖 PROBLEM 3

### 기능 요구 사항

- 369 게임규칙 : 3, 6, 9가 들어가는 숫자는 숫자를 말하는 대신 3, 6, 9의 개수만큼 손뼉을 쳐야 한다.
- number가 매개변수로 주어질 때, 1부터 number까지 손뼉을 몇 번 쳐야하는지 구현한다.

### 제한사항

- number는 1 이상 10,000 이하인 자연수이다.

### 체크포인트

- [o] 1부터 number까지 모든 수의 자릿수를 한 배열에 넣는다.
- [o] 배열에서 3,6,9만 filter해준다.
- [o] filter를 거친 배열의 length를 리턴한다.
- refactor
  - for문 while 문으로 대체
  - filter 제거 후 match를 이용한 정규표현식으로 대체

### 학습메모

조금 더 간단한 로직을 구현하기 위해 고민을 했다.

## 🔖 PROBLEM 4

### 기능 요구 사항

- 청개구리 사전을 참고해 입력 문자열을 변환해 리턴한다.

### 제한사항

- word는 길이가 1 이상 1,000 이하인 문자열이다.
- 알파벳 외의 문자는 변환하지 않는다.
- 알파벳 대문자는 알파벳 대문자로, 알파벳 소문자는 알파벳 소문자로 변환한다.

### 체크포인트

- [o] string.prototype.replace() 와 정규표현식을 이용해 알파벳을 변경해주는 로직 구현
- [o] 소문자를 변경하는 함수 작성
- [o] 대문자를 변경하는 함수 작성
- refactor
  - if문 가독성 좋게 변경

### 학습메모

## 🔖 PROBLEM 5

### 기능 요구 사항

- money가 매개변수로 주어질 때 <br/>
  [50000, 10000, 5000, 1000, 500, 100, 50, 10, 1]과 같이 각 몇 개로 변환되는지 배열에 담아 리턴한다.

### 제한사항

- money는 1 이상 1,000,000 이하인 자연수이다.

### 체크포인트

- [o] 선언된 배열을 탐색하며 새로운 배열을 만들어 리턴한다.

### 학습메모

## 🔖 PROBLEM 6

### 기능 요구 사항

- 신청받은 닉네임 중 같은 글자가 연속적으로 포함된 닉네임을 작성한 지원자들의 이메일 목록을 리턴한다.

### 제한사항

- 두 글자 이상의 문자가 연속적으로 순서에 맞추어 포함되어 있는 경우 중복으로 간주한다.
- 크루는 1명 이상 10,000명 이하이다.
- 이메일은 이메일 형식에 부합하며, 전체 길이는 11자 이상 20자 미만이다.
- 신청할 수 있는 이메일은 `email.com` 도메인으로만 제한한다.
- 닉네임은 한글만 가능하고 전체 길이는 1자 이상 20자 미만이다.
- result는 이메일에 해당하는 부분의 문자열을 오름차순으로 정렬하고 중복은 제거한다.

### 체크포인트

- [o] 중복확인하는 로직
- [o] 결과배열 오름차순으로 출력하기
- [o] 결과배열 중복 제거하기
- refactor
  - if문 가독성 좋게 변경
  - 하위 스코프에 상위 스코프와 동일한 이름으로 선언된 변수명 변경
  - return 없는 map을 forEach로 변경
  - 가독성을 높이기 위해 if문과 concat 대신 스프레트 연산 이용

## 🔖 PROBLEM 7

### 기능 요구 사항

- 친구 추천 알고리즘을 구현하고자 아래와 같은 규칙을 세웠다.
  - 사용자와 함께 아는 친구의 수 = 10점
  - 사용자의 타임 라인에 방문한 횟수 = 1점
- 친구 추천 규칙에 따라 높은 점수 순으로 최대 5명을 리턴한다.
- 추천 점수가 같은 경우 이름순으로 정렬한다.

### 제한사항

- user는 길이가 1 이상 30 이하인 문자열이다.
- friends는 길이가 1 이상 10,000 이하인 배열이다.
- friends의 각 원소는 길이가 2인 배열로 [아이디 A, 아이디 B] 순으로 들어있다.
  - A와 B는 친구라는 의미이다.
  - 아이디는 길이가 1 이상 30 이하인 문자열이다.
- visitors는 길이가 0 이상 10,000 이하인 배열이다.
- 사용자 아이디는 알파벳 소문자로만 이루어져 있다.
- 동일한 친구 관계가 중복해서 주어지지 않는다.
- 추천할 친구가 없는 경우는 주어지지 않는다.

### 체크포인트

- [o] 친구관계를 나타내는 그래프를 만들고 간선 추가
- [o] 추천점수를 나타내는 객체를 만들고 함께 아는 친구들의 점수 더하기
- [o] 추천점수를 나타내는 객체에 방문자들의 점수 더하기
- [o] 요구사항에 맞게 정렬하고 최대 5명의 친구를 추천해주기
- refactor
  - 가독성을 높이기 위해 if문과 concat 대신 스프레트 연산 이용

### 학습메모
