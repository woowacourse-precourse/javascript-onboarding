## 목차

- [Problem 1](#-problem-1)
- [Problem 2](#-problem-2)
- [Problem 3](#-problem-3)
- [Problem 4](#-problem-4)
- [Problem 5](#-problem-5)
- [Problem 6](#-problem-6)
- [Problem 7](#-problem-7)

## 🔖 PROBLEM 1

### 제한사항

- 책은 1페이지부터 400페이지까지 있다.
- 왼쪽페이지는 홀수, 오른쪽페이지는 짝수이다.
- 시작 면이나 마지막 면이 나오도록 책을 펼치지 않는다.

### 기능 요구 사항

- 예외사항은 -1을 return 한다.
- 포비가 이긴다면 1, 크롱이 이긴다면 2, 무승부는 0을 리턴한다.

### 체크포인트

- [o] 입력 예외사항을 캐치하는 함수를 만든다.
- [o] 한 페이지의 가장 높은 점수를 리턴하는 함수를 만든다.
- [o] 두 페이지를 비교해 점수를 확정하는 함수를 만든다.
- [o] 최종적으로 problem1 함수를 완성해준다.
- refactor
  - 메소드 체이닝에 인덴트를 넣어 새로운 문이 아닌 메소드 호출인 것을 강조해주기

### 학습메모

## 🔖 PROBLEM 2

### 기능 요구 사항

- 연속하는 중복 문자열을 삭제한 결과를 리턴한다.
- 중복문자열을 제거할 수 없을 때까지 반복한다.

### 제한사항

- cryptogram은 길이가 1 이상 1000 이하인 문자열이다.
- cryptogram은 알파벳 소문자로만 이루어져 있다.

### 체크포인트

- [o] ~~stack을 이용해 중복을 제거하는 로직구현~~
- [o] 정규표현식을 이용해 중복을 제거하는 로직구현

### 학습메모

처음에 스택을 이용해 같은 문자가 나오면 pop해주는 방식으로 구현을 했었다. 하지만 이렇게 하면 문제의 기능 요구 사항에서 제시해준 순서와 맞지 않는다고 생각하여 정규표현식을 이용하는 방식으로 변경해 보았다.

## 🔖 PROBLEM 3

### 기능 요구 사항

- 369 게임규칙 : 3, 6, 9가 들어가는 숫자는 숫자를 말하는 대신 3, 6, 9의 개수만큼 손뼉을 쳐야 한다.
- number가 매개변수로 주어질 때, 1부터 number까지 손뼉을 몇 번 쳐야하는지 구현한다.

### 제한사항

- number는 1 이상 10,000 이하인 자연수이다.

### 체크포인트

- [o] 1부터 number까지 모든 수의 자릿수를 한 배열에 넣는다.
- [o] 배열에서 3,6,9만 filter해준다.
- [o] filter를 거친 배열의 length를 리턴한다.
- refactor
  - ~~for문 while 문으로 대체~~
    - 함수형으로 변경
  - filter 제거 후 match를 이용한 정규표현식으로 대체

### 학습메모

조금 더 간단한 로직을 구현하기 위해 고민을 했다.

## 🔖 PROBLEM 4

### 기능 요구 사항

- 청개구리 사전을 참고해 입력 문자열을 변환해 리턴한다.

### 제한사항

- word는 길이가 1 이상 1,000 이하인 문자열이다.
- 알파벳 외의 문자는 변환하지 않는다.
- 알파벳 대문자는 알파벳 대문자로, 알파벳 소문자는 알파벳 소문자로 변환한다.

### 체크포인트

- [o] string.prototype.replace() 와 정규표현식을 이용해 알파벳을 변경해주는 로직 구현
- [o] 소문자를 변경하는 함수 작성
- [o] 대문자를 변경하는 함수 작성
- refactor
  - if문 가독성 좋게 변경
  - opposite 로직 변경
  - replace 함수를 한 번 호출로 변경

### 학습메모

## 🔖 PROBLEM 5

### 기능 요구 사항

- money가 매개변수로 주어질 때 <br/>
  [50000, 10000, 5000, 1000, 500, 100, 50, 10, 1]과 같이 각 몇 개로 변환되는지 배열에 담아 리턴한다.

### 제한사항

- money는 1 이상 1,000,000 이하인 자연수이다.

### 체크포인트

- [o] 선언된 배열을 탐색하며 새로운 배열을 만들어 리턴한다.
- refactor
  - 매개변수의 값을 변경하는 안티패턴 제거

### 학습메모

## 🔖 PROBLEM 6

### 기능 요구 사항

- 신청받은 닉네임 중 같은 글자가 연속적으로 포함된 닉네임을 작성한 지원자들의 이메일 목록을 리턴한다.

### 제한사항

- 두 글자 이상의 문자가 연속적으로 순서에 맞추어 포함되어 있는 경우 중복으로 간주한다.
- 크루는 1명 이상 10,000명 이하이다.
- 이메일은 이메일 형식에 부합하며, 전체 길이는 11자 이상 20자 미만이다.
- 신청할 수 있는 이메일은 `email.com` 도메인으로만 제한한다.
- 닉네임은 한글만 가능하고 전체 길이는 1자 이상 20자 미만이다.
- result는 이메일에 해당하는 부분의 문자열을 오름차순으로 정렬하고 중복은 제거한다.

### 체크포인트

- [o] 중복확인하는 로직
- [o] 결과배열 오름차순으로 출력하기
- [o] 결과배열 중복 제거하기
- refactor
  - if문 가독성 좋게 변경
  - 하위 스코프에 상위 스코프와 동일한 이름으로 선언된 변수명 변경
  - return 없는 map을 forEach로 변경
  - 가독성을 높이기 위해 if문과 concat 대신 스프레트 연산 이용
  - 모호한 변수명 가독성 좋게 변경
  - 메소드 체이닝에 인덴트를 넣어 새로운 문이 아닌 메소드 호출인 것을 강조해주기
  - 닉네임의 부분집합을 구하는 로직 수정

### 학습메모

리팩토링을 하면서 비트마스크를 이용해 부분문자열들을 추출하는 방법을 생각해보았다. 하지만 오히려 코드의 가독성이 더 떨어지는 것 같아 원래 이중반복문 방식을 유지하기로 했다.

```javascript
function getPartsOfNickname(nickname) {
  let flag = 3;
  const parts = [];
  while (flag < Math.pow(2, nickname.length)) {
    parts.push(
      [...nickname].filter((_, idx) => Math.pow(2, idx) & flag).join("")
    );
    if (flag << 1 < Math.pow(2, nickname.length)) {
      flag = flag << 1;
    } else {
      flag = flag * 2 + 1;
    }
  }
  return parts;
}
```

기존에 닉네임이 가질 수 있는 모든 부분집합(부분문자열)을 뽑아내는 방식을 이용해 중복을 판별했었다.
하지만 조금만 생각해보니 중복문자열이 무엇인지는 필요없고 중복인지 아닌지가 중요한 문제였다.
따라서 부분집합을 모두 뽑아낼 필요 없이 두글자짜리 부분문자열만 뽑아내면 기존 방식보다 더 간단하게 중복을 처리할 수 있었다.

## 🔖 PROBLEM 7

### 기능 요구 사항

- 친구 추천 알고리즘을 구현하고자 아래와 같은 규칙을 세웠다.
  - 사용자와 함께 아는 친구의 수 = 10점
  - 사용자의 타임 라인에 방문한 횟수 = 1점
- 친구 추천 규칙에 따라 높은 점수 순으로 최대 5명을 리턴한다.
- 추천 점수가 같은 경우 이름순으로 정렬한다.

### 제한사항

- user는 길이가 1 이상 30 이하인 문자열이다.
- friends는 길이가 1 이상 10,000 이하인 배열이다.
- friends의 각 원소는 길이가 2인 배열로 [아이디 A, 아이디 B] 순으로 들어있다.
  - A와 B는 친구라는 의미이다.
  - 아이디는 길이가 1 이상 30 이하인 문자열이다.
- visitors는 길이가 0 이상 10,000 이하인 배열이다.
- 사용자 아이디는 알파벳 소문자로만 이루어져 있다.
- 동일한 친구 관계가 중복해서 주어지지 않는다.
- 추천할 친구가 없는 경우는 주어지지 않는다.

### 체크포인트

- [o] 친구관계를 나타내는 그래프를 만들고 간선 추가
- [o] 추천점수를 나타내는 객체를 만들고 함께 아는 친구들의 점수 더하기
- [o] 추천점수를 나타내는 객체에 방문자들의 점수 더하기
- [o] 요구사항에 맞게 정렬하고 최대 5명의 친구를 추천해주기
- refactor
  - 가독성을 높이기 위해 if문과 concat 대신 스프레트 연산 이용
  - 기능별로 함수만들어 분리하기
  - 클로저를 이용해 score 객체 관리하기
  - 커스텀 정렬함수 분리하기
  - 추천알고리즘 부분의 동일로직 함수로 분리
  - user의 친구가 한명도 없을 때 오류 수정
  - 클로저 로직을 ES2019 방식으로 최신화

### 학습메모
