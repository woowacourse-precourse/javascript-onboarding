<br>

# 📋 [Problem1 Solving]

<br>

## 📌 요구사항

1 ~ 400 페이지  
왼쪽은 홀수, 오른쪽은 짝수  
한 사람당 왼쪽, 오른쪽 페이지가 각각 주어짐.  
다음 규칙의 게임을 이긴 사람이 책을 갖는다.

1. 각 페이지 번호의 각 숫자를 모두 더하거나, 모두 곱해 가장 큰 수를 구함.
2. 각 사람은 두 페이지의 점수 중, 가장 큰 점수를 자신의 점수라 하고 비교한다.
3. 첫번째, 마지막 페이지는 펼치지 않음. 즉, 1, 400 페이지는 입력 되지 않는다.
4. 포비가 이긴다면 1, 크롱이 이긴다면 2, 무승부는 0, 예외사항은 -1 로 return

## ❗예외사항

1. 왼쪽 오른쪽 페이지 번호가 같은 경우.
2. 왼쪽 페이지 번호가 오른쪽 페이지 번호보다 높은 경우.
3. 두 번호의 차이가 1을 넘어가는 경우.

=> 왼쪽페이지에서 오른쪽페이지를 뺏을 때 -1이 나오지 않는 경우들은 모두 에외상황이다.

## 📲 기능 목록

> 1. 페이지 번호의 각 숫자들을 더한 값을 구해준다. => _pageNumEachPlus 함수_
>
> - 숫자 리스트를 파라미터로 받는다. (parameter: numList)
> - 총합을 return 한다.
>
> 2. 페이지 번호의 각 숫자들을 곱한 값을 구해준다. => _pageNumEachMultiply 함수_
>
> - 숫자 리스트를 파라미터로 받는다. (parameter: numList)
> - 총곱을 return 한다.
>
> 3. 예외사항에 해당하는 것이 있는지 확인해준다. => _except 함수_

---

<br>

# 📋 [Problem2 Solving]

<br>

## 📌 요구사항

문자열이 주어진다.  
문자열에서 2개 이상 중복되는 문자가 이어져있다면 삭제 시킨다.  
삭제된 빈자리를 다시 양쪽의 문자를 땡겨서 채운다.

위 과정을 반복해서 더 이상 중복되는 문자가 연이어 나오지 않는다면 그 문자를 return.

## 📝 해결전략

> 연속되는 문자가 짝수개 단위라면 스택에 넣었다가 pop 하는 방법을 쓰면 되지만,  
> 이 방법을 쓰면 연속되는 문자 개수가 홀수일경우가 예외사항 발생한다.

따라서, 이 문제는 문자를 빈배열에 저장해가면서  
이전에 담은 문자가 넣을 문자랑 같다면 배열에 저장하지 않는다.  
이때, 변수 하나를 boolean 값으로 설정하여 같은 단어가 연속으로 나오는 중인지를 체크하게 해준다.  
연속으로 삭제가 되다가 이제 값이 달라지면, boolean 값을 다시 바꿔주고 배열에 저장되어있는 연속되던 값을 pop 시키자.

최종적으로 남은 문자를 return

## 📲 기능 목록

> # 1. 연속되는 중복 된 문자를 제거해주는 함수 => _deleteWords 함수_
>
> - 단어를 newWords 라는 스택에 담아준다.
> - 이전에 담은 단어랑 현재 담을 단어가 같다면, 현재 단어는 스택에 담지 않는다.
> - 이때, 연속되는 단어가 나왔다는 알림으로 check 변수를 true 로 바꿔준다.
> - 또한, 연속되는 단어가 나와 단어의 변화가 생긴다는 알림으로 newtRepeat도 true로 바꿔준다.
> - nextRepeat가 true로 리턴될 경우, deleteWords 함수가 다시 호출 된다.
> - 연속되는 단어가 중단된 경우, 스택에 저장된 연속된 단어를 pop 시킨다.
> - 또한, 해당 단어가 연속되는 것이 끝났다는 것을 알리기 위해 check 를 false로 바꿔준다.
> - 순회를 다 끝난 뒤에 check 가 true로 남아있다면,
> - 스택에 지워야 할 단어가 하나 남아있는 것이므로 pop 시켜준다.
> - 만들어진 단어를 이어, nextRepeat 값과 함께 return 한다.
>
> # 2. while 문
>
> - deleteWords 가 return 하는 nextRepeat 값을 repeat 라는 변수에 할당 받는다.
> - repeat 변수가 true 라면 deleteWords 함수를 통해 연속되는 문자 삭제 작업이 수행되었다는 뜻이므로, return 받은 문자를 재차 deleteWords 함수에 담아 호출한다.
> - repeat 변수가 false 라면, 더이상 연속하는 문자가 존재하지 않는 것이므로 while문을 종료한다.

---

<br>

# 📋 [Problem3 Solving]

<br>

## 📌 요구사항

1번 부터 주어진 숫자까지 369 게임을 실행.  
총 몇번의 박수를 쳤는지 구하여라.  
참고로, 각 숫자에서 3,6,9 숫자에 각각 한번씩 박수를 친다.

## 📝 해결전략

1번부터 숫자를 증가시키면서,  
각 문자의 369개수를 체크해주는 함수를 호출해 결과값을 더해나아가자.

## 📲 기능목록

> ### 1. 문자의 369 개수를 세어주는 함수. => cntNum function
>
> - 파라미터로 확인할 숫자를 전달 받는다. (parameter: num)
> - restNum 이라는 변수에 3 or 6 or 9 인 숫자만 filter로 정리하여 저장한다.
> - restNum 변수의 길이가 곧, 3 or 6 or 9 인 숫자들의 개수이므로 이 값을 return 한다.
>
> ### 2. return 받은 값을 cnt 변수에 더해주기.
>
> - cntNum 함수를 통해 return 받은 값을 cnt 변수에 합산해준다.
> - 최종적으로 cnt 변수에 담긴 값이 총 몇번의 박수를 쳐야하는 지에 대한 해답이다.

---

<br>

# 📋 [Problem4 Solving]

<br>

## 📌 요구사항

입력되는 문자를 청개구리 사전을 참고하여 해당하는 문자로 바꾸어라.  
바꾼 결과값을 출력.

## 📝 해결전략

아스키코드를 이용해야겠다.  
A-Z 는 65번부터 90번, a-z 는 97번부터 122번  
우선, 대문자인지 소문자인지를 나눠주자.  
대문자일경우,  
주어지는 각 문자의 아스키코드값에서 65를 빼고 남은 숫자만큼을 90에서 빼어서  
그 결과값을 아스키코드로 변환하여 저장시켜주면 되겠다.  
소문자일 경우,
비슷하게 한다. 대신 65=>97, 90=>122으로 생각해서 풀면 되겠다.

## 📲 기능목록

1. 입력된 번호에 맞는 청개구리사전 문자를 return 시켜주는 함수. => frogDict function

---

<br>

# 📋 [Problem5 Solving]

<br>

## 📌 요구사항

돈의 액수를 줄 수 있는 화폐로 나눈다.  
이때, 화폐 개수의 총합이 최소가 되게 하여라.  
1<= money <=1000000

## 📝 해결전략

50000부터 1원까지 차례로 나눠가면서 몫을 더해주고 나머지만 게속 남아가게 하자.  
중간에 나머지가 0이 되면 종료.

## 📲 기능목록

1. 각 화페에 맞게 금액을 나눠서 나머지를 도출해나아가는 함수 => divideCurrency

---

<br>

# 📋 [Problem6 Solving]

<br>

## 📌 요구사항

닉네임 중 같은 글자가 연속적으로 포함 될 경우 두 계정 모두 사용 제한.  
사용제한이 걸린 계정의 이메일을 문자열 오름차순 정렬하여 return  
이때, 중복은 제거하라.

## 📝 해결전략

dict 를 사용하자.
닉네임의 연속된 조합 단어를 dict에 키값으로 저장하고 카운트 1씩해줌.  
이때, 같은 글자가 연속적으로 포함된다면 같은 키값을 가질 것이고, 카운트는 1이 넘어가게됨.  
이 값들을 찾아내어. 해당 키값을 가지고 있는 계정들의 이메일을 따로 저장.  
문자열 중복제거하고 정렬하여 출력.

## ⚠️ 주의!

refuseEmail 함수에서 map 을 사용하면 email 을 두번 이상 중복되게 추가할 수도 있으므로
for loop 사용했다.

## 📲 기능목록

1. 닉네임으로 만들어질 수 있는 연속된 문자열 생성시켜 return 해주는 함수 => makeKeys
2. 입력된 닉네임을 키값에 넣어주는 함수 => enterDict
3. 키값의 value 값이 2개 이상인 값들을 return 해주는 함수 => checkValue
4. 사용제한될 이메일을 return 해주는 함수 => refuseEmail

---

<br>

# 📋 [Problem7 Solving]

<br>

## 📌 요구사항

서로의 친구관계가 담긴 배열이 주어짐. 두명은 서로 친구라는 뜻.  
user 의 타임라인 방문자 리스트도 주어짐.

user 와 함께 아는 친구의 수 +=10  
user 타임라인 방문횟수 +=1

해서 0점과 현재이미 친구인 사람들을 제외한 사람들을 점수대로 내림차순 해서 출력하여라.  
점수가 같을 시 이름순 정렬. 출력값은 5명이 최대.

## 📝 해결전략

서로 친구에 대한 정보를 양방향으로 저장.  
dict에 각 아이디의 배열 index 번호 정보를 담아주자.  
해당 아이디의 index 번호에 해당 아이디의 친구 정보가 담겨있다.  
user 정보는 배열 0번째 인덱스에 저장.

## 📲 기능목록

1. friends 를 순회하면서 dict에 각 아이디 인덱스 정보와 배열을 생성해줄 함수  
   => createInfo , 파라미터 값: 친구 관계 friends, 인덱스 idx
2. 각 아이디의 점수를 카운트해줄 함수 => cntScore
3. 함께아는 친구의 수에 대한 정보를 점수화 시켜 카운트해줄 함수 => cntKnowScore
4. (1) 점수 내림차순  
   (2) 이름 내림차순  
   정렬 함수 => sortList
5. 결과값을 출력해주고 정렬하여 return 해줄 함수 => makeResult
