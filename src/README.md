# 우아한 테크 코스 프리코스 1주차
> 문제를 풀면서 Vanilla js를 쓰면서 새롭게 알게된 내용과 구현 과정을 작성합니다.

## problem1

### 풀이 과정
주어진 pobi와 crong의 페이지를 각 자리수로 분리하여 array에 저장하고
다 더해보거나 다 곱해서 어떤 것이 큰지 비교한 후
pobi의 최대값과 crong의 최대값을 비교하고 그에 따른 결과를 return하도록 하였음

+) 예외의 경우가 있다는 것을 알고 예외의 경우를 다음과 같이 고려하여 먼저 처리하도록 수정하였음

* 페이지가 두 쪽이 아닌 여러쪽이 제공된 경우
* 1쪽과 400쪽을 포함하거나 1쪽 미만, 400쪽 초과하는 페이지가 제공된 경우
* 왼쪽 페이지가 짝수이거나 오른쪽 페이지가 홀수인 경우
* 두 페이지가 연속되지 않았을 경우

### js 문법

> MDN 문서를 참고하였음
* forEach(): Array 클래스에 포함된 메서드로 파이썬의 for elements in list: 와 같이 사용가능함
  다음 예시와 같이 파이썬의 enumerate()를 안 써도 value와 index에 동시에 접근이 가능하고 최대 array까지에 접근이 가능함
  무조건 index와 array는 생략해도 되지만 그러기 위해서는 index를 사용하려면 value를, array를 사용하려면 index를 작성해야 함
```
fruits.forEach(function (value, index, array) {
  console.log(item, index)
})
// for문으로 작성할 경우
for (let i=0; i<fruits.length; i++) {
  console.log(fruits[i])
}
```
* 나누기 할당(/=): 파이썬과 같이 나누기해서 할당하지만 몫 할당(//=)은 없음
* Math: 수학 계산을 위한 상수나 함수를 갖고 있는 내장 객체, 파이썬에서 기본으로 제공하는 함수들 대부분이 존재함
* floor(): Math 객체에 포함된 메서드로 이름 그대로 버림 함수이며 인자는 버림하고자 하는 숫자 1개만 받음, 몫 할당이 되지 않아서 사용하였음
* push(): Array 클래스에 포함된 메서드로 파이썬 List의 append()와 같음, 해당 array의 오른쪽에 인자를 원소로 추가함
* unshift(): push()와 같으나 맨 앞에 추가, 반대로 shift는 맨 앞의 원소를 제거하며 반환
* max(): Math 객체에 포함된 메서드로 인자들을 비교하여 높은 값을 가진 인자를 반환
* else if: 파이썬 elif 대신 else if를 사용

### js 코드 스타일

> 구글의 자바스크립트 스타일 가이드를 참고 하였음
* if문의 조건과 중괄호는 모두 띄어 작성한다
```
if (conditions) {
  // ...
}
```
* 함수를 camelCase, 변수명을 snake_case로 작성하는 파이썬과 달리 자바스크립트는 전부 `camelCase`로 작성함



## problem2

> 문제를 풀면서 Vanilla js를 쓰면서 새롭게 알게된 내용과 구현 과정을 작성합니다.

### 풀이 과정
주어진 cryptogram을 js의 자료 구조와 내장 함수를 이용해 풀려다 정규표현식이 생각나서 해당 방법으로 선회하여 접근하였음
처음에는 `/[a-z]{2,}/g`로 접근했다가 전혀 원하는 결과를 얻지 못해 그룹화라는 기능을 검색하여 알게 된 후
`/([a-z])\1+/g`로 수정하여 원하는 결과를 얻을 수 있었음
정규표현식을 이용해 연속해서 중복이되는 문자열을 빈 문자열로 교체하고
교체하기 전과 후가 같을 때까지 반복하는 과정으로 문제를 해결하였음

### js 코드 스타일

> 구글의 자바스크립트 스타일 가이드를 참고 하였음
* 문자열을 선언할 때는 작은따옴표('')를 사용하고 문자열 내에 작은따옴표가 있을 때는 백틱(``)을 사용함



## problem3

> 문제를 풀기 전 구현할 기능을 작성하고, Vanilla js를 쓰면서 새롭게 알게된 내용과 구현 과정을 작성합니다.

### 구현할 기능

* 각 자리수를 한 자리의 숫자로 이루어진 배열로 반환
* 각 자리수에서 3의 배수의 개수를 세어 반환
* for문을 통해 1부터 주어진 숫자까지 위의 기능을 호출하고, 반환된 수를 누적하여 더하여 반환

### 풀이 과정

문제 1번과 비슷한 접근 방법으로 숫자를 자릿수로 분리 한 뒤에 배열에 넣었고 해당 배열의 원소에서 3의 배수를 확인하였음

3의 배수를 확인하니 0도 또한 카운트가 되어서, 한자리의 숫자만을 계산한다고 감안하고 3, 6, 9인지 확인하는 함수로 수정하였음

### js 코드 스타일

> 구글의 자바스크립트 스타일 가이드를 참고하였음

* 각 문장이 끝날 때에는 `세미콜론(;)`을 붙여야 함



## problem4

> 문제를 풀기 전 구현할 기능을 작성하고, 문제를 풀면서 Vanilla js에서 새롭게 알게된 내용과 구현 과정을 작성합니다.

### 구현할 기능

* 알파벳을 ascii코드, 즉 일련의 숫자로 변환할 수 있다는 것을 이용해 ~~해당 숫자를 index로 갖으며 해당 index에 주어진 조건에 맞는 알파벳을 원소로 갖는 배열을~~ 함수를 만들어 사용
* 위의 배열을 이용해 알파벳을 변환하여 반환
* 알파벳이면 위의 기능을 이용하고 그렇지 않으면 그대로 사용하여 문자열을 완성

### 풀이 과정

배열을 만드려고 했으나 function외부에 만들 수 없었고, function내부에 만들면 호출 될 때마다 해당 배열을 만들 것이므로 encoding 함수를 구현하여 해결하였음

String 클래스의 메서드인 charCodeAt()을 사용하여 ascii코드로 변환하였고 fromCharCode()를 사용하여 ascii코드를 문자열로 다시 변환하는 과정을 통해 문제를 해결하였음

### js 문법

> MDN 문서를 참고하였음

* charCodeAt()과 pointCodeAt(): 두 함수 모두 String 클래스에 포함된 함수로 index를 인자로 받아 index에 해당하는 문자를 ascii코드로 변환하여 반환함
* fromCharCode()와 fromCodePoint: 위의 함수의 역함수(?)로 마찬가지로 String 클래스에 포함되어 있고, 유니코드에 해당하는 1개 이상의 정수를 인자로 받아서 일련의 문자열로 변환해 반환함



## problem5

### 구현할 기능

* 각 금액별로 해당 금액보다 크면 그만큼 빼고 뺀 회수만큼 더해주는 함수를 구현
* 특히 5만원을 체크하는 함수에서는 이보다 큰 수가 들어올 때 너무 많은 반복을 막기위해 50만원을 체크하는 부분을 추가

### 풀이 과정

주어진 금액에서 각 화폐의 금액보다 크면 계속해서 빼면서 회수를 카운팅하고 회수를 반환하는 함수를 만들었음

해당 함수를 problem5 함수에서 호출하여 answer 배열에 추가하는 방식으로 구현하였음

코드가 너무 길다고 판단되어 각 함수에서 while문을 제거하여 값을 반환할 수 있도록 수정하였고, 각 함수에서 사용한 상수를 problem5 함수에서도 사용할 수 있도록 전역변수로 선언하였음

answer 배열에 push하는 것보다 마지막 각 화폐의 개수를 호출하여 바로 return하는 것이 보기 편하다고 생각되어 해당 방법으로 수정하였음



## problem6

### 구현할 기능

* 주어진 forms를 순회하면서 사람의 이름을 2글자씩 끊어서 key-value 형태의 object의 key값으로 사용하고 value에는 이메일을 추가
* set 객체를 만들어서 위에서 만든 object를 순회하면서 value의 길이가 2이상인 것만 추가
* set 객체를 정렬하여 반환
  * set 객체를 array 객체로 변환한 뒤에 정렬 하였음

### 풀이 과정

주어진 forms를 순회하면서 사람의 이름을 2글자씩 끊어서 key-value 형태의 object의 key값으로 사용하고 value에는 이메일을 추가하였음

중복되는 메일을 없애기 위해 set 객체를 만들어서 위에서 만든 object를 순회하면서 value의 길이가 2이상인 것만 추가하였음

연락을 취할 이메일을 담은 set 객체를 array 객체로 변환하고 정렬하여 반환 하였음

### js 문법

> MDN문서 및 구글링을 통해 얻은 정보와 실험을 통해 얻은 정보를 작성하였음

MDN 문서의 methods를 확인해보면 다음과 같이 중간에 `.prototype.`이 들어가 있는 것을 확인할 수 있음

```
Array.prototype.forEach()
Array.from()
```

`.prototype.`이 있는 것은 객체를 새로 만들면 해당 객체에 자동으로 상속받는 메소드이며 `<객체명>.<함수명>()`으로 사용하면 되지만, 없는 것은 `<클래스명>.<함수명>()`꼴과 같이 클래스 이름을 호출한 뒤에 사용해야 함

* `for ... in ~`과 `for ... of ~`: 파이썬의 `for ... in ~`구문과 같이 객체 안의 값을 반복하여 사용할 때 쓰는 구문임, 단 `for ... in ~`은 객체의 반복, `for ... of ~`은 배열의 반복에 사용함, 반대로 사용하면 빈 값을 사용하게 될 수 있음

  +) 추가로 Set 객체의 내장 함수인 values()가 반환하는 객체는 array이므로 `for ... of ~`를 사용해야함

* Array.from(): Array 클래스에 포함된 메서드로 함수의 인자를 array 형으로 형바꿈을 해주는 함수

* substr(start_idx, length): 문자열에 내장된 함수로 해당 idx부터 길이에 해당하는 만큼 slice하는 함수

* add(): 배열에는 push()함수를 사용하는 것과 달리 Set에는 add()를 사용함
* 오브젝트를 생성할 때에는 `new Set();` `new Object();` 와 같이 제대로(new 포함) 명시하지 않으면 내장함수가 상속되지 않아 사용 불가능한 경우가 있음
* has(), hasOwnProperty(): `has()`는 Set에서 사용하고, `hasOwnProperty()`는 Object에서 인자로 받은 key가 존재하는지 확인하는 함수



## problem7

### 구현할 기능

* 사람의 이름을 key, 친구를 원소로하는 Set을 value로 갖는 오브젝트를 구현
* for문을 돌면서 위의 오브젝트에 친구관계를 표현
* 사람의 이름을 key, 친구 추천 점수를 원소로 하는 오브젝트를 구현
* for문을 돌면서 직접적인 친구는 아니면서 함께 아는 친구의 수 * 10 점 증가
* visitors를 돌면서 직접적인 친구가 아니라면 1점씩 증가

### 풀이 과정

사람의 이름을 key, 친구를 원소로하는 Set을 value로 갖는 오브젝트를 구현하여 friends를 for문으로 돌면서 해당 오브젝트에 친구관계를 표현함

사람의 이름을 key, 친구 추천 점수를 value로 하는 Map 객체를 선언하고 , 친구관계를 for문으로 돌면서 자신과 친구가 아니고, 연결된 친구라면 10점을 한 번만 추가하도록 구현 -> 함께 아는 친구 수 만큼 10점씩 부과되므로 연결 되었을 때마다 10점씩 부여하도록 하였음

마지막으로 map 객체를 array로 변환하여 sort함수를 적용하였고 다시 map객체로 변환하여 key 값만 불러온 뒤에 array로 변환하여 반환하였음

### js 문법

> MDN문서 및 구글링을 통해 얻은 정보와 실험을 통해 얻은 정보를 작성하였음

* Object 는 array로 변환하기 어렵지만 Map은 array로 변환하기 쉬움
* 기본으로 제공되는 sort()는 배열에서만 가능함



