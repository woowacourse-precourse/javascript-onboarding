/* 
  기능 목록
  - 예외 처리
    - 길이 1인 문자열
  - 현재 문자와 다음문자가 동일한지 비교
  - 현재 문자와 다음문자가 동일하면 인덱스 증감
    - 현재 문자 인덱스는 -1, 다음 문자 인덱스는 + 1
  - 현재 문자와 다음문자가 다르면 인덱스 증가
    - 현재 문자 인덱스, 다음 문자 인덱스 각각 + 1

  아이디어
  - 투포인터(start, end 인덱스의 문자가 같은지 비교)
*/

function 연속하는_원소_인덱스_찾기(문자열) {
  return [...문자열].findIndex(
    (원소, 인덱스, 배열) => 원소 === 배열.at(인덱스 + 1)
  );
}

function 중복_문자_제거하기(문자열) {
  while (true) {
    const 기준_인덱스 = 연속하는_원소_인덱스_찾기(문자열);

    if (기준_인덱스 === -1) {
      return 문자열;
    }

    문자열 = 문자열.slice(0, 기준_인덱스) + 문자열.slice(기준_인덱스 + 2);
  }
}

function problem2(문자열) {
  return 중복_문자_제거하기(문자열);
}

module.exports = problem2;
