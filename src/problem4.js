const _ = require("./myFunction.js");

/* 
  기능 목록
  - word의 첫 문자부터 루프 시작
  - 문자가 알파벳인지 판별
    - 알파벳이면 해당 문자의 반대 문자 구하기
      - 반대 문자는 규칙을 찾아 객체 구조로 생성
      - 해당 문자가 대문자이면 반대 문자를 대문자로 반환
      - 해당 문자가 소문자이면 반대 문자를 소문자로 반환
*/

function 아스키_값_구하기(문자) {
  return 문자.charCodeAt(0);
}

function 소문자이면(문자) {
  const 아스키_값 = 아스키_값_구하기(문자);
  const a_아스키_값 = 아스키_값_구하기("a");
  const z_아스키_값 = 아스키_값_구하기("z");
  const 범위에_속한다면 = _.범위_함수_생성하기(a_아스키_값, z_아스키_값);

  return 범위에_속한다면(아스키_값);
}

function 대문자이면(문자) {
  const 아스키_값 = 아스키_값_구하기(문자);
  const A_아스키_값 = 아스키_값_구하기("A");
  const Z_아스키_값 = 아스키_값_구하기("Z");
  const 범위에_속한다면 = _.범위_함수_생성하기(A_아스키_값, Z_아스키_값);

  return 범위에_속한다면(아스키_값);
}

function 소문자_반대문자_변환하기(소문자) {
  const 소문자_배열 = _.연속_값_배열_만들기(
    아스키_값_구하기("a"),
    아스키_값_구하기("z"),
    1
  ).map((아스키_값) => String.fromCharCode(아스키_값));
  const 반대_문자_배열 = [...소문자_배열].reverse();

  return 반대_문자_배열[소문자_배열.indexOf(소문자)];
}

function 대문자_반대문자_변환하기(대문자) {
  const 대문자_배열 = _.연속_값_배열_만들기(
    아스키_값_구하기("A"),
    아스키_값_구하기("Z"),
    1
  ).map((아스키_값) => String.fromCharCode(아스키_값));
  const 반대_문자_배열 = [...대문자_배열].reverse();

  return 반대_문자_배열[대문자_배열.indexOf(대문자)];
}

function 정수이면(값) {
  return Number.isInteger(값);
}

function 소문자_인덱스_추출하기(문자_배열) {
  return 문자_배열
    .map((문자, 인덱스) => 소문자이면(문자) && 인덱스)
    .filter(정수이면);
}

function 대문자_인덱스_추출하기(문자_배열) {
  return 문자_배열
    .map((문자, 인덱스) => 대문자이면(문자) && 인덱스)
    .filter(정수이면);
}

function problem4(단어) {
  const 문자_배열 = [...단어];
  const 소문자_인덱스_배열 = 소문자_인덱스_추출하기(문자_배열);
  const 대문자_인덱스_배열 = 대문자_인덱스_추출하기(문자_배열);

  소문자_인덱스_배열.forEach(
    (인덱스) =>
      (문자_배열[인덱스] = 소문자_반대문자_변환하기(문자_배열[인덱스]))
  );
  대문자_인덱스_배열.forEach(
    (인덱스) =>
      (문자_배열[인덱스] = 대문자_반대문자_변환하기(문자_배열[인덱스]))
  );

  return 문자_배열.join("");
}

module.exports = problem4;
