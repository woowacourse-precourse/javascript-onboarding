/* 
  기능 목록
  - 각각의 이름이 가지는 연속하는 길이 2의 문자열 추출하기(예: 제이엠 => ['제이', '이엠'])
  - 키(추출한 문자) - 값(빈 배열) 객체 만들기(예: {'제이': [], '이엠': []})
  - 이름-이메일 쌍 배열을 순회하며 빈 배열에 이메일 추가하기
  - 추가한 이메일의 개수가 2개 이상이면 중복
  - 중복인 이메일들을 추출
  - 추출한 이메일들을 정렬 후 반환
*/

function 연속_문자_배열_구하기(문자열) {
  const 연속_문자_배열 = [];

  for (let 인덱스 = 0; 인덱스 < 문자열.length - 1; 인덱스 += 1) {
    연속_문자_배열.push(문자열[인덱스] + 문자열[인덱스 + 1]);
  }

  return 연속_문자_배열;
}

function 부분_문자열_인지(문자열, 부분_문자열_배열) {
  for (const 부분_문자열 of 부분_문자열_배열) {
    if (문자열.includes(부분_문자열)) return true;
  }

  return false;
}

function problem6(이메일_이름_쌍_배열) {
  const 이름별_연속_문자_배열 = 이메일_이름_쌍_배열
    .map(([이메일, 이름]) => 이름)
    .map(연속_문자_배열_구하기);

  const 연속_문자_객체 = 이름별_연속_문자_배열
    .flatMap((연속_문자_배열) => 연속_문자_배열)
    .reduce((객체, 연속_문자) => {
      객체[연속_문자] = 객체[연속_문자] || 0;
      객체[연속_문자] += 1;

      return 객체;
    }, {});

  const 중복_연속_문자_배열 = Object.entries(연속_문자_객체)
    .filter(([연속_문자, 개수]) => 개수 > 1)
    .map(([연속_문자]) => 연속_문자);

  return 이메일_이름_쌍_배열
    .filter(([이메일, 이름]) => 부분_문자열_인지(이름, 중복_연속_문자_배열))
    .map(([이메일]) => 이메일)
    .sort();
}

module.exports = problem6;
